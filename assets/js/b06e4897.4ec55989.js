"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[682],{4549:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-digital-twin/week-4-physics-simulation-in-gazebo/chapter-8-gazebo-ros2-integration","title":"Gazebo ROS 2 Integration","description":"Overview","source":"@site/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo/chapter-8-gazebo-ros2-integration.md","sourceDirName":"module-2-digital-twin/week-4-physics-simulation-in-gazebo","slug":"/module-2-digital-twin/week-4-physics-simulation-in-gazebo/chapter-8-gazebo-ros2-integration","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo/chapter-8-gazebo-ros2-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadwaheedairi/hackathon_textbook_ai_robotics/edit/main/my-website/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo/chapter-8-gazebo-ros2-integration.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Gazebo ROS 2 Integration","sidebar_label":"Chapter 8: Gazebo ROS 2 Integration","sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 7: Physics Fundamentals","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo/chapter-7-physics-simulation-fundamentals"},"next":{"title":"Chapter 9: Unity Rendering","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity/chapter-9-unity-rendering-pipelines"}}');var i=s(4848),o=s(8453);const r={title:"Gazebo ROS 2 Integration",sidebar_label:"Chapter 8: Gazebo ROS 2 Integration",sidebar_position:8},a="Chapter 8: Gazebo ROS 2 Integration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:2},{value:"Gazebo-ROS 2 Integration",id:"gazebo-ros-2-integration",level:2},{value:"Message Bridges",id:"message-bridges",level:3},{value:"TF Tree Integration",id:"tf-tree-integration",level:3},{value:"Service Interfaces",id:"service-interfaces",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"ROS 2 Node for Gazebo Interaction",id:"ros-2-node-for-gazebo-interaction",level:3},{value:"Physics Parameter Configuration Node",id:"physics-parameter-configuration-node",level:3},{value:"Advanced Physics Simulation with Custom Contact Detection",id:"advanced-physics-simulation-with-custom-contact-detection",level:3},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-8-gazebo-ros-2-integration",children:"Chapter 8: Gazebo ROS 2 Integration"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This chapter explores the integration between Gazebo and ROS 2, enabling seamless communication between simulated robots and ROS 2 control systems. You'll learn how to bridge simulation and real-world robotics workflows."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(n.admonition,{title:"Learning Objectives",type:"info",children:[(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Integrate Gazebo with ROS 2 for robot simulation"}),"\n",(0,i.jsx)(n.li,{children:"Use gazebo_ros_pkgs for communication bridges"}),"\n",(0,i.jsx)(n.li,{children:"Control simulated robots through ROS 2 interfaces"}),"\n",(0,i.jsx)(n.li,{children:"Configure physics parameters dynamically from ROS 2"}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,i.jsx)(n.p,{children:"SDF is the native format for describing simulation worlds in Gazebo. It extends URDF capabilities to include simulation-specific features like physics properties, sensors, and plugins. An SDF file typically contains world definitions, model definitions, light sources, and plugins."}),"\n",(0,i.jsx)(n.p,{children:"Basic SDF structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="default">\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    <model name="robot">\n      \x3c!-- Model definition --\x3e\n    </model>\n\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n    </light>\n  </world>\n</sdf>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"gazebo-ros-2-integration",children:"Gazebo-ROS 2 Integration"}),"\n",(0,i.jsxs)(n.p,{children:["The integration between Gazebo and ROS 2 is facilitated by the ",(0,i.jsx)(n.code,{children:"gazebo_ros_pkgs"})," package, which provides plugins and tools for seamless communication. Key integration points include message bridges, TF tree integration, and service interfaces."]}),"\n",(0,i.jsx)(n.h3,{id:"message-bridges",children:"Message Bridges"}),"\n",(0,i.jsx)(n.p,{children:"The integration provides automatic bridges between Gazebo topics and ROS 2 topics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/clock"})," synchronization for simulation time"]}),"\n",(0,i.jsx)(n.li,{children:"Sensor data publishing to ROS 2 topics"}),"\n",(0,i.jsx)(n.li,{children:"Actuator command subscription from ROS 2 topics"}),"\n",(0,i.jsx)(n.li,{children:"Model state publishing and subscription"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"tf-tree-integration",children:"TF Tree Integration"}),"\n",(0,i.jsx)(n.p,{children:"Gazebo automatically publishes transforms for all simulated models, creating a complete TF tree that ROS 2 nodes can use for spatial reasoning."}),"\n",(0,i.jsx)(n.h3,{id:"service-interfaces",children:"Service Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"The integration provides ROS 2 services for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Model spawning and deletion"}),"\n",(0,i.jsx)(n.li,{children:"World state management"}),"\n",(0,i.jsx)(n.li,{children:"Simulation control (pause, reset, step)"}),"\n",(0,i.jsx)(n.li,{children:"Physics parameter adjustment"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.h3,{id:"ros-2-node-for-gazebo-interaction",children:"ROS 2 Node for Gazebo Interaction"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom gazebo_msgs.srv import SpawnEntity, DeleteEntity\nfrom gazebo_msgs.msg import ModelStates\nfrom std_srvs.srv import Empty\nimport time\n\nclass GazeboControllerNode(Node):\n    def __init__(self):\n        super().__init__(\'gazebo_controller_node\')\n\n        self.spawn_client = self.create_client(SpawnEntity, \'/spawn_entity\')\n        self.delete_client = self.create_client(DeleteEntity, \'/delete_entity\')\n        self.pause_client = self.create_client(Empty, \'/pause_physics\')\n        self.unpause_client = self.create_client(Empty, \'/unpause_physics\')\n        self.reset_client = self.create_client(Empty, \'/reset_simulation\')\n\n        self.model_states_sub = self.create_subscription(\n            ModelStates,\n            \'/model_states\',\n            self.model_states_callback,\n            10\n        )\n\n        self.cmd_vel_pub = self.create_publisher(\n            Twist,\n            \'/cmd_vel\',\n            10\n        )\n\n        while not self.spawn_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Waiting for spawn service...\')\n\n        while not self.delete_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Waiting for delete service...\')\n\n        self.get_logger().info(\'Gazebo Controller Node initialized\')\n\n    def spawn_model(self, model_name, model_xml, robot_namespace=\'\'):\n        """Spawn a model in Gazebo"""\n        request = SpawnEntity.Request()\n        request.name = model_name\n        request.xml = model_xml\n        request.robot_namespace = robot_namespace\n\n        future = self.spawn_client.call_async(request)\n        return future\n\n    def delete_model(self, model_name):\n        """Delete a model from Gazebo"""\n        request = DeleteEntity.Request()\n        request.name = model_name\n\n        future = self.delete_client.call_async(request)\n        return future\n\n    def pause_simulation(self):\n        """Pause the physics simulation"""\n        future = self.pause_client.call_async(Empty.Request())\n        return future\n\n    def unpause_simulation(self):\n        """Unpause the physics simulation"""\n        future = self.unpause_client.call_async(Empty.Request())\n        return future\n\n    def reset_simulation(self):\n        """Reset the entire simulation"""\n        future = self.reset_client.call_async(Empty.Request())\n        return future\n\n    def model_states_callback(self, msg):\n        """Handle model states updates"""\n        for i, name in enumerate(msg.name):\n            if name == \'mobile_robot\':\n                position = msg.pose[i].position\n                velocity = msg.twist[i].linear\n                self.get_logger().info(\n                    f\'Robot {name} position: ({position.x:.2f}, {position.y:.2f}, {position.z:.2f}), \'\n                    f\'velocity: ({velocity.x:.2f}, {velocity.y:.2f}, {velocity.z:.2f})\'\n                )\n\n    def send_velocity_command(self, linear_x=0.0, angular_z=0.0):\n        """Send velocity command to simulated robot"""\n        cmd_msg = Twist()\n        cmd_msg.linear.x = linear_x\n        cmd_msg.angular.z = angular_z\n        self.cmd_vel_pub.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    gazebo_controller = GazeboControllerNode()\n\n    try:\n        gazebo_controller.send_velocity_command(linear_x=0.5, angular_z=0.2)\n        time.sleep(2.0)\n        gazebo_controller.send_velocity_command()\n        rclpy.spin_once(gazebo_controller, timeout_sec=1.0)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        gazebo_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"physics-parameter-configuration-node",children:"Physics Parameter Configuration Node"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\nfrom gazebo_msgs.srv import SetPhysicsProperties, GetPhysicsProperties\nfrom gazebo_msgs.msg import ODEPhysics\nfrom geometry_msgs.msg import Vector3\n\nclass PhysicsConfigNode(Node):\n    def __init__(self):\n        super().__init__('physics_config_node')\n\n        self.set_physics_client = self.create_client(\n            SetPhysicsProperties,\n            '/set_physics_properties'\n        )\n        self.get_physics_client = self.create_client(\n            GetPhysicsProperties,\n            '/get_physics_properties'\n        )\n\n        self.timer = self.create_timer(5.0, self.adjust_physics_properties)\n\n        self.get_logger().info('Physics Configuration Node initialized')\n\n    def get_current_physics_properties(self):\n        \"\"\"Get current physics properties from Gazebo\"\"\"\n        while not self.get_physics_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for get physics service...')\n\n        request = GetPhysicsProperties.Request()\n        future = self.get_physics_client.call_async(request)\n\n        rclpy.spin_until_future_complete(self, future)\n        return future.result()\n\n    def set_physics_properties(self, time_step=0.001, max_update_rate=1000.0,\n                              gravity=(0, 0, -9.8)):\n        \"\"\"Set physics properties in Gazebo\"\"\"\n        while not self.set_physics_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for set physics service...')\n\n        request = SetPhysicsProperties.Request()\n        request.time_step = time_step\n        request.max_update_rate = max_update_rate\n\n        gravity_msg = Vector3()\n        gravity_msg.x = gravity[0]\n        gravity_msg.y = gravity[1]\n        gravity_msg.z = gravity[2]\n        request.gravity = gravity_msg\n\n        request.ode_config.auto_disable_bodies = False\n        request.ode_config.sor_pgs_precon_iters = 2\n        request.ode_config.sor_pgs_iters = 50\n        request.ode_config.sor_pgs_w = 1.3\n        request.ode_config.contact_surface_layer = 0.001\n        request.ode_config.contact_max_correcting_vel = 100.0\n        request.ode_config.cfm = 0.0\n        request.ode_config.erp = 0.2\n        request.ode_config.max_contacts = 20\n\n        future = self.set_physics_client.call_async(request)\n        return future\n\n    def adjust_physics_properties(self):\n        \"\"\"Adjust physics properties based on simulation requirements\"\"\"\n        current_props = self.get_current_physics_properties()\n\n        if current_props:\n            self.get_logger().info(f'Current time step: {current_props.time_step}')\n            self.get_logger().info(f'Current max update rate: {current_props.max_update_rate}')\n            self.get_logger().info(f'Current gravity: {current_props.gravity}')\n\n        self.get_logger().info('Physics properties checked/adjusted')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    physics_config_node = PhysicsConfigNode()\n\n    try:\n        rclpy.spin(physics_config_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        physics_config_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-physics-simulation-with-custom-contact-detection",children:"Advanced Physics Simulation with Custom Contact Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\nfrom gazebo_msgs.msg import ContactsState\nimport math\n\nclass AdvancedPhysicsController(Node):\n    def __init__(self):\n        super().__init__(\'advanced_physics_controller\')\n\n        self.contact_sub = self.create_subscription(\n            ContactsState,\n            \'/contact_sensor_state\',\n            self.contact_callback,\n            10\n        )\n\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            \'/laser_scan\',\n            self.scan_callback,\n            10\n        )\n\n        self.cmd_vel_pub = self.create_publisher(\n            Twist,\n            \'/cmd_vel\',\n            10\n        )\n\n        self.timer = self.create_timer(0.1, self.physics_control_loop)\n\n        self.collision_detected = False\n        self.collision_force = 0.0\n        self.scan_ranges = []\n        self.safe_distance = 1.0\n\n        self.get_logger().info(\'Advanced Physics Controller initialized\')\n\n    def contact_callback(self, msg):\n        """Handle contact sensor messages"""\n        if len(msg.states) > 0:\n            self.collision_detected = True\n            if len(msg.states[0].wrenches) > 0:\n                force = msg.states[0].wrenches[0].force\n                self.collision_force = math.sqrt(\n                    force.x**2 + force.y**2 + force.z**2\n                )\n            self.get_logger().info(f\'Collision detected with force: {self.collision_force:.2f}\')\n        else:\n            self.collision_detected = False\n            self.collision_force = 0.0\n\n    def scan_callback(self, msg):\n        """Handle laser scan messages"""\n        self.scan_ranges = msg.ranges\n\n    def physics_control_loop(self):\n        """Main physics-based control loop"""\n        cmd_msg = Twist()\n\n        if self.scan_ranges:\n            front_scan = self.scan_ranges[len(self.scan_ranges)//2]\n            if not math.isinf(front_scan) and front_scan < self.safe_distance:\n                cmd_msg.linear.x = 0.2 * (front_scan / self.safe_distance)\n                cmd_msg.angular.z = 0.0\n            else:\n                cmd_msg.linear.x = 0.5\n                cmd_msg.angular.z = 0.0\n        else:\n            cmd_msg.linear.x = 0.3\n            cmd_msg.angular.z = 0.0\n\n        if self.collision_detected:\n            cmd_msg.linear.x = -0.3\n            cmd_msg.angular.z = 0.5\n            self.get_logger().info(\'Collision response: reversing and turning\')\n\n        self.cmd_vel_pub.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    physics_controller = AdvancedPhysicsController()\n\n    try:\n        rclpy.spin(physics_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        physics_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Gazebo-ROS 2 integration enables comprehensive robot simulation with seamless communication between simulated environments and ROS 2 control systems. This integration supports model spawning, physics configuration, and sensor data streaming for effective robot development and testing."}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsx)(n.admonition,{title:"Key Takeaways",type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SDF format provides simulation-specific features beyond URDF capabilities"}),"\n",(0,i.jsx)(n.li,{children:"gazebo_ros_pkgs bridges Gazebo and ROS 2 communication"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic physics configuration enables adaptive simulation environments"}),"\n",(0,i.jsx)(n.li,{children:"Contact sensors and collision detection support safety-critical testing"}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,i.jsx)(n.p,{children:"In the next chapter, we'll explore high-fidelity rendering in Unity, learning how to create photorealistic environments for advanced robot perception training."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);