"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[821],{7651:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-digital-twin/week-4-physics-simulation-in-gazebo","title":"Physics Simulation in Gazebo","description":"Learning Objectives","source":"@site/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/week-4-physics-simulation-in-gazebo","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadwaheedairi/hackathon_textbook_ai_robotics/edit/main/my-website/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Physics Simulation in Gazebo","sidebar_label":"Week 4: Physics Simulation in Gazebo","sidebar_position":1},"sidebar":"textbookSidebar","previous":{"title":"Week 3: Python Agent Integration with ROS Controllers + URDF Modeling","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-3-python-agent-integration"},"next":{"title":"Week 5: High-Fidelity Rendering in Unity","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity"}}');var t=i(4848),o=i(8453);const r={title:"Physics Simulation in Gazebo",sidebar_label:"Week 4: Physics Simulation in Gazebo",sidebar_position:1},l="Physics Simulation in Gazebo",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Theory",id:"theory",level:2},{value:"Physics Simulation Fundamentals",id:"physics-simulation-fundamentals",level:3},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:4},{value:"Collision Detection and Response",id:"collision-detection-and-response",level:4},{value:"Friction and Contact Models",id:"friction-and-contact-models",level:4},{value:"Gravity and Environmental Forces",id:"gravity-and-environmental-forces",level:4},{value:"Gazebo Architecture and Components",id:"gazebo-architecture-and-components",level:3},{value:"Server Component (gzserver)",id:"server-component-gzserver",level:4},{value:"Client Component (gzclient)",id:"client-component-gzclient",level:4},{value:"Model Database and World Files",id:"model-database-and-world-files",level:4},{value:"Sensor Simulation",id:"sensor-simulation",level:4},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"Gazebo-ROS 2 Integration",id:"gazebo-ros-2-integration",level:3},{value:"Message Bridges",id:"message-bridges",level:4},{value:"TF Tree Integration",id:"tf-tree-integration",level:4},{value:"Service Interfaces",id:"service-interfaces",level:4},{value:"Physics Engine Options",id:"physics-engine-options",level:3},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:4},{value:"Bullet",id:"bullet",level:4},{value:"Simbody",id:"simbody",level:4},{value:"DART (Dynamic Animation and Robotics Toolkit)",id:"dart-dynamic-animation-and-robotics-toolkit",level:4},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Simplified Collision Models",id:"simplified-collision-models",level:4},{value:"Fixed Time Steps",id:"fixed-time-steps",level:4},{value:"Level of Detail (LOD)",id:"level-of-detail-lod",level:4},{value:"Code Examples",id:"code-examples",level:2},{value:"Basic Gazebo World File",id:"basic-gazebo-world-file",level:3},{value:"Gazebo Plugin Example - Custom Physics Controller",id:"gazebo-plugin-example---custom-physics-controller",level:3},{value:"ROS 2 Node for Gazebo Interaction",id:"ros-2-node-for-gazebo-interaction",level:3},{value:"Physics Parameter Configuration Node",id:"physics-parameter-configuration-node",level:3},{value:"Advanced Physics Simulation with Custom Contact Detection",id:"advanced-physics-simulation-with-custom-contact-detection",level:3},{value:"Physics-based Trajectory Planning with Dynamic Obstacles",id:"physics-based-trajectory-planning-with-dynamic-obstacles",level:3},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"physics-simulation-in-gazebo",children:"Physics Simulation in Gazebo"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this week, students will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the fundamentals of physics simulation in robotics"}),"\n",(0,t.jsx)(n.li,{children:"Configure Gazebo for realistic physics simulation"}),"\n",(0,t.jsx)(n.li,{children:"Implement sensor simulation in Gazebo environments"}),"\n",(0,t.jsx)(n.li,{children:"Integrate Gazebo with ROS 2 for robot simulation"}),"\n",(0,t.jsx)(n.li,{children:"Create custom physics worlds and models"}),"\n",(0,t.jsx)(n.li,{children:"Validate robot behavior in simulated environments"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Physics simulation is a critical component of robotics development, allowing engineers to test algorithms, validate robot designs, and train AI systems in a safe, controlled environment. Gazebo has emerged as the leading physics simulation platform for robotics, providing realistic simulation of rigid body dynamics, sensors, and environmental conditions. This week explores the fundamentals of physics simulation in Gazebo and its integration with ROS 2 for comprehensive robot development."}),"\n",(0,t.jsx)(n.p,{children:"Gazebo provides a sophisticated physics engine that accurately models real-world forces, collisions, and interactions. By simulating these physical properties, researchers can validate robot behaviors before deploying to real hardware, significantly reducing development time and costs. The integration with ROS 2 enables seamless communication between simulated robots and real-world algorithms, creating a powerful development pipeline."}),"\n",(0,t.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,t.jsx)(n.h3,{id:"physics-simulation-fundamentals",children:"Physics Simulation Fundamentals"}),"\n",(0,t.jsx)(n.p,{children:"Physics simulation in robotics involves modeling the behavior of physical systems using computational methods. The core components include:"}),"\n",(0,t.jsx)(n.h4,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"Rigid body dynamics form the foundation of physics simulation, describing how objects move and interact under the influence of forces. In Gazebo, each simulated object is treated as a rigid body with properties like mass, center of mass, and inertia tensor. The physics engine calculates the motion of these bodies by solving Newton's equations of motion."}),"\n",(0,t.jsx)(n.p,{children:"The motion of a rigid body is determined by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Linear motion"}),": F = ma (Force equals mass times acceleration)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Angular motion"}),": \u03c4 = I\u03b1 (Torque equals moment of inertia times angular acceleration)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Gazebo supports multiple physics engines including ODE (Open Dynamics Engine), Bullet, Simbody, and DART, each with different characteristics for accuracy and performance."}),"\n",(0,t.jsx)(n.h4,{id:"collision-detection-and-response",children:"Collision Detection and Response"}),"\n",(0,t.jsx)(n.p,{children:"Collision detection algorithms determine when objects intersect or come into contact. Gazebo uses sophisticated algorithms to detect collisions between complex geometries efficiently. Once a collision is detected, the physics engine calculates the appropriate response based on material properties, friction coefficients, and restitution (bounciness)."}),"\n",(0,t.jsx)(n.p,{children:"Collision geometries supported in Gazebo include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Primitive shapes"}),": Box, sphere, cylinder, capsule"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mesh shapes"}),": Complex geometries defined by triangle meshes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Heightmaps"}),": Terrain defined by height values"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"friction-and-contact-models",children:"Friction and Contact Models"}),"\n",(0,t.jsx)(n.p,{children:"Friction models determine how objects interact when in contact. Gazebo implements both static and dynamic friction models, allowing for realistic simulation of various surface interactions. The ODE physics engine uses a contact model that includes parameters for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mu (\u03bc)"}),": Primary friction coefficient"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mu2"}),": Secondary friction coefficient (for anisotropic friction)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fdir1"}),": Direction of the friction force"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slip values"}),": Parameters for slip-based friction models"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"gravity-and-environmental-forces",children:"Gravity and Environmental Forces"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo simulates gravitational forces by applying a constant acceleration to all objects in the world. The gravity vector can be customized to simulate different environments (e.g., moon, Mars). Additional environmental forces like wind can be simulated using plugins."}),"\n",(0,t.jsx)(n.h3,{id:"gazebo-architecture-and-components",children:"Gazebo Architecture and Components"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo is built on a modular architecture that separates the physics simulation from the rendering and user interface components:"}),"\n",(0,t.jsx)(n.h4,{id:"server-component-gzserver",children:"Server Component (gzserver)"}),"\n",(0,t.jsx)(n.p,{children:"The server component handles the physics simulation, sensor simulation, and plugin execution. It runs headlessly and can be controlled through command-line tools or programmatic interfaces. The server manages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Physics engine execution"}),"\n",(0,t.jsx)(n.li,{children:"Sensor data generation"}),"\n",(0,t.jsx)(n.li,{children:"Model and world state updates"}),"\n",(0,t.jsx)(n.li,{children:"Plugin loading and execution"}),"\n",(0,t.jsx)(n.li,{children:"Communication with client interfaces"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"client-component-gzclient",children:"Client Component (gzclient)"}),"\n",(0,t.jsx)(n.p,{children:"The client component provides the graphical user interface for visualizing the simulation. It connects to the server component to display the 3D world and allows user interaction through mouse and keyboard controls. The client handles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"3D rendering using OGRE"}),"\n",(0,t.jsx)(n.li,{children:"User input processing"}),"\n",(0,t.jsx)(n.li,{children:"Visualization of physics properties"}),"\n",(0,t.jsx)(n.li,{children:"Camera control and scene management"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"model-database-and-world-files",children:"Model Database and World Files"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo uses SDF (Simulation Description Format) files to define models, worlds, and simulation parameters. SDF is an XML-based format similar to URDF but designed specifically for simulation. World files define the complete simulation environment including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initial model positions and states"}),"\n",(0,t.jsx)(n.li,{children:"Physics engine parameters"}),"\n",(0,t.jsx)(n.li,{children:"Environmental properties (gravity, atmosphere)"}),"\n",(0,t.jsx)(n.li,{children:"Lighting and rendering settings"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo provides realistic simulation of various sensor types including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Camera sensors"}),": RGB, depth, stereo cameras"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LIDAR sensors"}),": 2D and 3D laser range finders"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IMU sensors"}),": Inertial measurement units"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Force/Torque sensors"}),": Joint force and torque measurements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GPS sensors"}),": Global positioning simulation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contact sensors"}),": Collision detection sensors"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,t.jsx)(n.p,{children:"SDF is the native format for describing simulation worlds in Gazebo. It extends URDF capabilities to include simulation-specific features like physics properties, sensors, and plugins. An SDF file typically contains:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"World definition"}),": Environment, gravity, physics engine settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Model definitions"}),": Robot and object descriptions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Light sources"}),": Lighting configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plugins"}),": Custom simulation logic"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Basic SDF structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="default">\n    \x3c!-- World properties --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Models --\x3e\n    <model name="robot">\n      \x3c!-- Model definition --\x3e\n    </model>\n\n    \x3c!-- Lights --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n    </light>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"gazebo-ros-2-integration",children:"Gazebo-ROS 2 Integration"}),"\n",(0,t.jsxs)(n.p,{children:["The integration between Gazebo and ROS 2 is facilitated by the ",(0,t.jsx)(n.code,{children:"gazebo_ros_pkgs"})," package, which provides plugins and tools for seamless communication. Key integration points include:"]}),"\n",(0,t.jsx)(n.h4,{id:"message-bridges",children:"Message Bridges"}),"\n",(0,t.jsx)(n.p,{children:"The integration provides automatic bridges between Gazebo topics and ROS 2 topics:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"/clock"})," synchronization for simulation time"]}),"\n",(0,t.jsx)(n.li,{children:"Sensor data publishing to ROS 2 topics"}),"\n",(0,t.jsx)(n.li,{children:"Actuator command subscription from ROS 2 topics"}),"\n",(0,t.jsx)(n.li,{children:"Model state publishing and subscription"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"tf-tree-integration",children:"TF Tree Integration"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo automatically publishes transforms for all simulated models, creating a complete TF tree that ROS 2 nodes can use for spatial reasoning."}),"\n",(0,t.jsx)(n.h4,{id:"service-interfaces",children:"Service Interfaces"}),"\n",(0,t.jsx)(n.p,{children:"The integration provides ROS 2 services for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Model spawning and deletion"}),"\n",(0,t.jsx)(n.li,{children:"World state management"}),"\n",(0,t.jsx)(n.li,{children:"Simulation control (pause, reset, step)"}),"\n",(0,t.jsx)(n.li,{children:"Physics parameter adjustment"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"physics-engine-options",children:"Physics Engine Options"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo supports multiple physics engines, each with different characteristics:"}),"\n",(0,t.jsx)(n.h4,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Default physics engine in Gazebo"}),"\n",(0,t.jsx)(n.li,{children:"Good balance of performance and accuracy"}),"\n",(0,t.jsx)(n.li,{children:"Supports complex joint types"}),"\n",(0,t.jsx)(n.li,{children:"Well-tested for robotics applications"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"bullet",children:"Bullet"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"High-performance physics engine"}),"\n",(0,t.jsx)(n.li,{children:"Good for real-time simulation"}),"\n",(0,t.jsx)(n.li,{children:"Supports soft body dynamics"}),"\n",(0,t.jsx)(n.li,{children:"Used in game development"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"simbody",children:"Simbody"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"High-fidelity multibody dynamics"}),"\n",(0,t.jsx)(n.li,{children:"Excellent for biomechanics simulation"}),"\n",(0,t.jsx)(n.li,{children:"More computationally intensive"}),"\n",(0,t.jsx)(n.li,{children:"Precise constraint handling"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"dart-dynamic-animation-and-robotics-toolkit",children:"DART (Dynamic Animation and Robotics Toolkit)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Advanced constraint handling"}),"\n",(0,t.jsx)(n.li,{children:"Support for complex kinematic chains"}),"\n",(0,t.jsx)(n.li,{children:"Good for humanoid robots"}),"\n",(0,t.jsx)(n.li,{children:"Hybrid rigid/soft body simulation"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Physics simulation can be computationally intensive. Several optimization strategies help maintain performance:"}),"\n",(0,t.jsx)(n.h4,{id:"simplified-collision-models",children:"Simplified Collision Models"}),"\n",(0,t.jsx)(n.p,{children:"Using simpler geometries for collision detection while maintaining detailed visual models improves performance without sacrificing accuracy."}),"\n",(0,t.jsx)(n.h4,{id:"fixed-time-steps",children:"Fixed Time Steps"}),"\n",(0,t.jsx)(n.p,{children:"Using fixed time steps for physics calculations ensures consistent behavior and can improve performance."}),"\n",(0,t.jsx)(n.h4,{id:"level-of-detail-lod",children:"Level of Detail (LOD)"}),"\n",(0,t.jsx)(n.p,{children:"Implementing multiple levels of detail for complex models allows the simulator to use simpler representations when performance is critical."}),"\n",(0,t.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-gazebo-world-file",children:"Basic Gazebo World File"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a simple Gazebo world file with physics simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="physics_simulation_example">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <gravity>0 0 -9.8</gravity>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Include ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include sky --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Simple box model --\x3e\n    <model name="box">\n      <pose>0 0 0.5 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.083</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.083</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.083</izz>\n          </inertia>\n        </inertial>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>\n            <diffuse>1 0 0 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Falling sphere model --\x3e\n    <model name="falling_sphere">\n      <pose>1 0 5 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>0.5</mass>\n          <inertia>\n            <ixx>0.025</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.025</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.025</izz>\n          </inertia>\n        </inertial>\n        <collision name="collision">\n          <geometry>\n            <sphere>\n              <radius>0.2</radius>\n            </sphere>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <sphere>\n              <radius>0.2</radius>\n            </sphere>\n          </geometry>\n          <material>\n            <ambient>0 0 1 1</ambient>\n            <diffuse>0 0 1 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"gazebo-plugin-example---custom-physics-controller",children:"Gazebo Plugin Example - Custom Physics Controller"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a custom Gazebo plugin for physics control:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/common/common.hh>\n#include <ignition/math/Pose3.hh>\n\nnamespace gazebo\n{\n  class PhysicsControllerPlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n    {\n      // Store the model pointer for later use\n      this->model = _model;\n\n      // Get parameters from SDF\n      this->target_x = 0.0;\n      if (_sdf->HasElement("target_x"))\n        this->target_x = _sdf->Get<double>("target_x");\n\n      // Listen to the update event. This event is broadcast every\n      // simulation iteration.\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n          std::bind(&PhysicsControllerPlugin::OnUpdate, this));\n    }\n\n    // Called by the world update start event\n    public: void OnUpdate()\n    {\n      // Apply a force to move the model toward the target position\n      auto current_pose = this->model->WorldPose();\n      double current_x = current_pose.Pos().X();\n\n      // Calculate error\n      double error = this->target_x - current_x;\n\n      // Apply proportional control force\n      ignition::math::Vector3d force(error * 10.0, 0.0, 0.0);\n      this->model->SetLinearVel(force * 0.1);\n    }\n\n    // Pointer to the model\n    private: physics::ModelPtr model;\n\n    // Target position\n    private: double target_x;\n\n    // Pointer to the update event connection\n    private: event::ConnectionPtr updateConnection;\n  };\n\n  // Register this plugin with the simulator\n  GZ_REGISTER_MODEL_PLUGIN(PhysicsControllerPlugin)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"ros-2-node-for-gazebo-interaction",children:"ROS 2 Node for Gazebo Interaction"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a ROS 2 node that interacts with Gazebo simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom gazebo_msgs.srv import SpawnEntity, DeleteEntity\nfrom gazebo_msgs.msg import ModelStates\nfrom std_srvs.srv import Empty\nimport time\n\nclass GazeboControllerNode(Node):\n    def __init__(self):\n        super().__init__(\'gazebo_controller_node\')\n\n        # Create service clients for Gazebo\n        self.spawn_client = self.create_client(SpawnEntity, \'/spawn_entity\')\n        self.delete_client = self.create_client(DeleteEntity, \'/delete_entity\')\n        self.pause_client = self.create_client(Empty, \'/pause_physics\')\n        self.unpause_client = self.create_client(Empty, \'/unpause_physics\')\n        self.reset_client = self.create_client(Empty, \'/reset_simulation\')\n\n        # Subscribe to model states\n        self.model_states_sub = self.create_subscription(\n            ModelStates,\n            \'/model_states\',\n            self.model_states_callback,\n            10\n        )\n\n        # Publisher for robot velocity commands\n        self.cmd_vel_pub = self.create_publisher(\n            Twist,\n            \'/cmd_vel\',\n            10\n        )\n\n        # Wait for services to be available\n        while not self.spawn_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Waiting for spawn service...\')\n\n        while not self.delete_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Waiting for delete service...\')\n\n        self.get_logger().info(\'Gazebo Controller Node initialized\')\n\n    def spawn_model(self, model_name, model_xml, robot_namespace=\'\'):\n        """Spawn a model in Gazebo"""\n        request = SpawnEntity.Request()\n        request.name = model_name\n        request.xml = model_xml\n        request.robot_namespace = robot_namespace\n\n        future = self.spawn_client.call_async(request)\n        return future\n\n    def delete_model(self, model_name):\n        """Delete a model from Gazebo"""\n        request = DeleteEntity.Request()\n        request.name = model_name\n\n        future = self.delete_client.call_async(request)\n        return future\n\n    def pause_simulation(self):\n        """Pause the physics simulation"""\n        future = self.pause_client.call_async(Empty.Request())\n        return future\n\n    def unpause_simulation(self):\n        """Unpause the physics simulation"""\n        future = self.unpause_client.call_async(Empty.Request())\n        return future\n\n    def reset_simulation(self):\n        """Reset the entire simulation"""\n        future = self.reset_client.call_async(Empty.Request())\n        return future\n\n    def model_states_callback(self, msg):\n        """Handle model states updates"""\n        for i, name in enumerate(msg.name):\n            if name == \'mobile_robot\':  # Example robot name\n                position = msg.pose[i].position\n                velocity = msg.twist[i].linear\n                self.get_logger().info(\n                    f\'Robot {name} position: ({position.x:.2f}, {position.y:.2f}, {position.z:.2f}), \'\n                    f\'velocity: ({velocity.x:.2f}, {velocity.y:.2f}, {velocity.z:.2f})\'\n                )\n\n    def send_velocity_command(self, linear_x=0.0, angular_z=0.0):\n        """Send velocity command to simulated robot"""\n        cmd_msg = Twist()\n        cmd_msg.linear.x = linear_x\n        cmd_msg.angular.z = angular_z\n        self.cmd_vel_pub.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    gazebo_controller = GazeboControllerNode()\n\n    # Example usage\n    try:\n        # Send a velocity command\n        gazebo_controller.send_velocity_command(linear_x=0.5, angular_z=0.2)\n\n        # Pause for a moment to see the effect\n        time.sleep(2.0)\n\n        # Stop the robot\n        gazebo_controller.send_velocity_command()\n\n        rclpy.spin_once(gazebo_controller, timeout_sec=1.0)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        gazebo_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"physics-parameter-configuration-node",children:"Physics Parameter Configuration Node"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of how to configure physics parameters dynamically:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64\nfrom gazebo_msgs.srv import SetPhysicsProperties, GetPhysicsProperties\nfrom gazebo_msgs.msg import ODEPhysics\nfrom geometry_msgs.msg import Vector3\n\nclass PhysicsConfigNode(Node):\n    def __init__(self):\n        super().__init__('physics_config_node')\n\n        # Create service clients for physics configuration\n        self.set_physics_client = self.create_client(\n            SetPhysicsProperties,\n            '/set_physics_properties'\n        )\n        self.get_physics_client = self.create_client(\n            GetPhysicsProperties,\n            '/get_physics_properties'\n        )\n\n        # Timer to periodically check and adjust physics properties\n        self.timer = self.create_timer(5.0, self.adjust_physics_properties)\n\n        self.get_logger().info('Physics Configuration Node initialized')\n\n    def get_current_physics_properties(self):\n        \"\"\"Get current physics properties from Gazebo\"\"\"\n        while not self.get_physics_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for get physics service...')\n\n        request = GetPhysicsProperties.Request()\n        future = self.get_physics_client.call_async(request)\n\n        # Wait for response\n        rclpy.spin_until_future_complete(self, future)\n        return future.result()\n\n    def set_physics_properties(self, time_step=0.001, max_update_rate=1000.0,\n                              gravity=(0, 0, -9.8)):\n        \"\"\"Set physics properties in Gazebo\"\"\"\n        while not self.set_physics_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for set physics service...')\n\n        request = SetPhysicsProperties.Request()\n        request.time_step = time_step\n        request.max_update_rate = max_update_rate\n\n        # Set gravity\n        gravity_msg = Vector3()\n        gravity_msg.x = gravity[0]\n        gravity_msg.y = gravity[1]\n        gravity_msg.z = gravity[2]\n        request.gravity = gravity_msg\n\n        # Set ODE parameters\n        request.ode_config.auto_disable_bodies = False\n        request.ode_config.sor_pgs_precon_iters = 2\n        request.ode_config.sor_pgs_iters = 50\n        request.ode_config.sor_pgs_w = 1.3\n        request.ode_config.contact_surface_layer = 0.001\n        request.ode_config.contact_max_correcting_vel = 100.0\n        request.ode_config.cfm = 0.0\n        request.ode_config.erp = 0.2\n        request.ode_config.max_contacts = 20\n\n        future = self.set_physics_client.call_async(request)\n        return future\n\n    def adjust_physics_properties(self):\n        \"\"\"Adjust physics properties based on simulation requirements\"\"\"\n        # Get current properties\n        current_props = self.get_current_physics_properties()\n\n        if current_props:\n            self.get_logger().info(f'Current time step: {current_props.time_step}')\n            self.get_logger().info(f'Current max update rate: {current_props.max_update_rate}')\n            self.get_logger().info(f'Current gravity: {current_props.gravity}')\n\n        # Example: Adjust for higher accuracy (smaller time step)\n        # self.set_physics_properties(time_step=0.0005, max_update_rate=2000.0)\n\n        self.get_logger().info('Physics properties checked/adjusted')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    physics_config_node = PhysicsConfigNode()\n\n    try:\n        rclpy.spin(physics_config_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        physics_config_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-physics-simulation-with-custom-contact-detection",children:"Advanced Physics Simulation with Custom Contact Detection"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a more advanced physics simulation with custom contact detection and response:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\nfrom gazebo_msgs.msg import ContactsState\nfrom std_msgs.msg import Float64\nimport math\n\nclass AdvancedPhysicsController(Node):\n    def __init__(self):\n        super().__init__(\'advanced_physics_controller\')\n\n        # Subscribe to contact sensors to detect collisions\n        self.contact_sub = self.create_subscription(\n            ContactsState,\n            \'/contact_sensor_state\',\n            self.contact_callback,\n            10\n        )\n\n        # Subscribe to laser scan for environment awareness\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            \'/laser_scan\',\n            self.scan_callback,\n            10\n        )\n\n        # Publisher for robot velocity commands\n        self.cmd_vel_pub = self.create_publisher(\n            Twist,\n            \'/cmd_vel\',\n            10\n        )\n\n        # Timer for physics-based control decisions\n        self.timer = self.create_timer(0.1, self.physics_control_loop)\n\n        # Physics parameters\n        self.collision_detected = False\n        self.collision_force = 0.0\n        self.scan_ranges = []\n        self.safe_distance = 1.0  # meters\n\n        self.get_logger().info(\'Advanced Physics Controller initialized\')\n\n    def contact_callback(self, msg):\n        """Handle contact sensor messages"""\n        if len(msg.states) > 0:\n            self.collision_detected = True\n            # Calculate collision force from the first contact\n            if len(msg.states[0].wrenches) > 0:\n                force = msg.states[0].wrenches[0].force\n                self.collision_force = math.sqrt(\n                    force.x**2 + force.y**2 + force.z**2\n                )\n            self.get_logger().info(f\'Collision detected with force: {self.collision_force:.2f}\')\n        else:\n            self.collision_detected = False\n            self.collision_force = 0.0\n\n    def scan_callback(self, msg):\n        """Handle laser scan messages"""\n        self.scan_ranges = msg.ranges\n\n    def physics_control_loop(self):\n        """Main physics-based control loop"""\n        cmd_msg = Twist()\n\n        # Check for obstacles in front\n        if self.scan_ranges:\n            front_scan = self.scan_ranges[len(self.scan_ranges)//2]  # Front reading\n            if not math.isinf(front_scan) and front_scan < self.safe_distance:\n                # Slow down when approaching obstacles\n                cmd_msg.linear.x = 0.2 * (front_scan / self.safe_distance)\n                cmd_msg.angular.z = 0.0\n            else:\n                # Normal speed when clear\n                cmd_msg.linear.x = 0.5\n                cmd_msg.angular.z = 0.0\n        else:\n            # Default forward movement\n            cmd_msg.linear.x = 0.3\n            cmd_msg.angular.z = 0.0\n\n        # If collision detected, reverse and turn\n        if self.collision_detected:\n            cmd_msg.linear.x = -0.3  # Move backward\n            cmd_msg.angular.z = 0.5  # Turn to avoid obstacle\n            self.get_logger().info(\'Collision response: reversing and turning\')\n\n        self.cmd_vel_pub.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    physics_controller = AdvancedPhysicsController()\n\n    try:\n        rclpy.spin(physics_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        physics_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"physics-based-trajectory-planning-with-dynamic-obstacles",children:"Physics-based Trajectory Planning with Dynamic Obstacles"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of physics-based trajectory planning that accounts for dynamic obstacles:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom gazebo_msgs.msg import ModelStates\nfrom visualization_msgs.msg import Marker\nfrom std_msgs.msg import Header\nimport math\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass PhysicsTrajectoryPlanner(Node):\n    def __init__(self):\n        super().__init__('physics_trajectory_planner')\n\n        # Subscribe to model states to track all objects in simulation\n        self.model_states_sub = self.create_subscription(\n            ModelStates,\n            '/model_states',\n            self.model_states_callback,\n            10\n        )\n\n        # Publisher for velocity commands\n        self.cmd_vel_pub = self.create_publisher(\n            Twist,\n            '/cmd_vel',\n            10\n        )\n\n        # Publisher for visualization markers\n        self.marker_pub = self.create_publisher(\n            Marker,\n            '/trajectory_visualization',\n            10\n        )\n\n        # Timer for trajectory planning\n        self.timer = self.create_timer(0.2, self.trajectory_planning_loop)\n\n        # Store model states\n        self.model_states = {}\n        self.robot_name = 'mobile_robot'  # Assuming this is our robot's name\n\n        self.get_logger().info('Physics Trajectory Planner initialized')\n\n    def model_states_callback(self, msg):\n        \"\"\"Update model states from Gazebo\"\"\"\n        for i, name in enumerate(msg.name):\n            pose = msg.pose[i]\n            twist = msg.twist[i]\n\n            self.model_states[name] = {\n                'position': np.array([pose.position.x, pose.position.y, pose.position.z]),\n                'orientation': np.array([pose.orientation.x, pose.orientation.y,\n                                        pose.orientation.z, pose.orientation.w]),\n                'linear_vel': np.array([twist.linear.x, twist.linear.y, twist.linear.z]),\n                'angular_vel': np.array([twist.angular.x, twist.angular.y, twist.angular.z])\n            }\n\n    def calculate_collision_probability(self, robot_pos, robot_vel, obstacle_pos, obstacle_vel):\n        \"\"\"Calculate collision probability based on current trajectories\"\"\"\n        # Simple collision prediction based on relative positions and velocities\n        rel_pos = obstacle_pos - robot_pos\n        rel_vel = obstacle_vel - robot_vel\n\n        # Calculate time to closest approach\n        rel_speed_squared = np.dot(rel_vel, rel_vel)\n        if rel_speed_squared < 1e-6:  # Very slow relative motion\n            return 0.0\n\n        t_ca = -np.dot(rel_pos, rel_vel) / rel_speed_squared\n        t_ca = max(0, t_ca)  # Only look forward in time\n\n        # Calculate closest approach distance\n        closest_pos = robot_pos + robot_vel * t_ca\n        closest_obstacle_pos = obstacle_pos + obstacle_vel * t_ca\n        dist_ca = np.linalg.norm(closest_obstacle_pos - closest_pos)\n\n        # Collision probability based on distance and safety margin\n        safety_margin = 0.5  # meters\n        if dist_ca < safety_margin:\n            return min(1.0, (safety_margin - dist_ca) / safety_margin)\n        else:\n            return 0.0\n\n    def trajectory_planning_loop(self):\n        \"\"\"Main trajectory planning loop with physics considerations\"\"\"\n        if self.robot_name not in self.model_states:\n            return\n\n        robot_state = self.model_states[self.robot_name]\n        robot_pos = robot_state['position']\n        robot_vel = robot_state['linear_vel']\n\n        # Check for potential collisions with other models\n        collision_risk = 0.0\n        avoidance_vector = np.array([0.0, 0.0, 0.0])\n\n        for model_name, model_state in self.model_states.items():\n            if model_name == self.robot_name:\n                continue  # Skip robot itself\n\n            # Calculate collision probability\n            collision_prob = self.calculate_collision_probability(\n                robot_pos, robot_vel,\n                model_state['position'], model_state['linear_vel']\n            )\n\n            if collision_prob > 0.1:  # Significant risk\n                collision_risk = max(collision_risk, collision_prob)\n\n                # Calculate avoidance direction (perpendicular to relative velocity)\n                rel_pos = model_state['position'] - robot_pos\n                rel_vel = model_state['linear_vel'] - robot_vel\n\n                # Create perpendicular vector for avoidance\n                avoidance_dir = np.array([-rel_pos[1], rel_pos[0], 0.0])\n                if np.linalg.norm(avoidance_dir) > 0:\n                    avoidance_dir = avoidance_dir / np.linalg.norm(avoidance_dir)\n                    avoidance_vector += avoidance_dir * collision_prob\n\n        # Generate velocity command based on collision risk\n        cmd_msg = Twist()\n\n        if collision_risk > 0.3:  # High risk\n            # Prioritize avoidance\n            cmd_msg.linear.x = 0.2  # Slow down\n            cmd_msg.angular.z = avoidance_vector[1] * 2.0  # Turn away from obstacles\n        else:\n            # Normal navigation\n            cmd_msg.linear.x = 0.5  # Move forward\n            cmd_msg.angular.z = 0.0  # No turning\n\n        self.cmd_vel_pub.publish(cmd_msg)\n\n        # Publish visualization marker for planned trajectory\n        self.publish_trajectory_marker(robot_pos, robot_vel)\n\n    def publish_trajectory_marker(self, robot_pos, robot_vel):\n        \"\"\"Publish visualization marker for the planned trajectory\"\"\"\n        marker = Marker()\n        marker.header = Header()\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.header.frame_id = 'map'\n        marker.ns = 'trajectory'\n        marker.id = 0\n        marker.type = Marker.ARROW\n        marker.action = Marker.ADD\n\n        # Set start point (robot position)\n        marker.points = []\n        start_point = marker.header.stamp  # This will be filled with actual position\n\n        # Calculate end point based on current velocity\n        end_pos = robot_pos + robot_vel * 2.0  # 2 seconds ahead\n\n        # Create start and end points\n        start_point = PoseStamped().pose.position\n        start_point.x = float(robot_pos[0])\n        start_point.y = float(robot_pos[1])\n        start_point.z = float(robot_pos[2])\n\n        end_point = PoseStamped().pose.position\n        end_point.x = float(end_pos[0])\n        end_point.y = float(end_pos[1])\n        end_point.z = float(end_pos[2])\n\n        marker.points = [start_point, end_point]\n\n        marker.scale.x = 0.1  # Shaft diameter\n        marker.scale.y = 0.2  # Head diameter\n        marker.color.a = 1.0  # Alpha\n        marker.color.r = 0.0  # Red\n        marker.color.g = 1.0  # Green\n        marker.color.b = 0.0  # Blue\n\n        self.marker_pub.publish(marker)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    trajectory_planner = PhysicsTrajectoryPlanner()\n\n    try:\n        rclpy.spin(trajectory_planner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        trajectory_planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create a Gazebo world with multiple objects and simulate their interactions"}),"\n",(0,t.jsx)(n.li,{children:"Implement a custom physics controller plugin for a simulated robot"}),"\n",(0,t.jsx)(n.li,{children:"Configure different physics engines and compare their behavior"}),"\n",(0,t.jsx)(n.li,{children:"Create a ROS 2 node that dynamically adjusts physics parameters during simulation"}),"\n",(0,t.jsx)(n.li,{children:"Simulate a mobile robot navigating through a complex environment with obstacles"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Gazebo Documentation: ",(0,t.jsx)(n.a,{href:"http://gazebosim.org/",children:"http://gazebosim.org/"})]}),"\n",(0,t.jsxs)(n.li,{children:["SDF Format Documentation: ",(0,t.jsx)(n.a,{href:"http://sdformat.org/",children:"http://sdformat.org/"})]}),"\n",(0,t.jsxs)(n.li,{children:["Gazebo-ROS 2 Integration: ",(0,t.jsx)(n.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"https://github.com/ros-simulation/gazebo_ros_pkgs"})]}),"\n",(0,t.jsx)(n.li,{children:"Physics Engine Comparison: ODE, Bullet, Simbody, DART documentation"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);