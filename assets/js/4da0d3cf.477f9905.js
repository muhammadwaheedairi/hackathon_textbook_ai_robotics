"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4360],{2884:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1-robotic-nervous-system/week-3-python-agent-integration","title":"Python Agent Integration with ROS Controllers + URDF Modeling","description":"Learning Objectives","source":"@site/docs/module-1-robotic-nervous-system/week-3-python-agent-integration.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/week-3-python-agent-integration","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-3-python-agent-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadwaheedairi/hackathon_textbook_ai_robotics/edit/main/my-website/docs/module-1-robotic-nervous-system/week-3-python-agent-integration.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Python Agent Integration with ROS Controllers + URDF Modeling","sidebar_label":"Week 3: Python Agent Integration with ROS Controllers + URDF Modeling","sidebar_position":3},"sidebar":"textbookSidebar","previous":{"title":"Week 2: ROS 2 Fundamentals \u2014 Nodes, Topics, Services, Packages","permalink":"/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-2-ros-2-fundamentals"},"next":{"title":"Week 4: Physics Simulation in Gazebo","permalink":"/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo"}}');var r=t(4848),i=t(8453);const s={title:"Python Agent Integration with ROS Controllers + URDF Modeling",sidebar_label:"Week 3: Python Agent Integration with ROS Controllers + URDF Modeling",sidebar_position:3},l="Python Agent Integration with ROS Controllers + URDF Modeling",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Theory",id:"theory",level:2},{value:"Python Agent Integration with ROS Controllers",id:"python-agent-integration-with-ros-controllers",level:3},{value:"Agent-Controller Architecture",id:"agent-controller-architecture",level:4},{value:"Types of ROS Controllers",id:"types-of-ros-controllers",level:4},{value:"Control Interface Patterns",id:"control-interface-patterns",level:4},{value:"Communication Mechanisms",id:"communication-mechanisms",level:4},{value:"Python Agent Implementation Considerations",id:"python-agent-implementation-considerations",level:4},{value:"ros2_control Framework Components",id:"ros2_control-framework-components",level:4},{value:"Controller Configuration",id:"controller-configuration",level:4},{value:"URDF (Unified Robot Description Format)",id:"urdf-unified-robot-description-format",level:3},{value:"URDF Components and Structure",id:"urdf-components-and-structure",level:4},{value:"URDF XML Structure",id:"urdf-xml-structure",level:4},{value:"Joint Types in Detail",id:"joint-types-in-detail",level:4},{value:"Geometry Types",id:"geometry-types",level:4},{value:"Inertial Properties",id:"inertial-properties",level:4},{value:"URDF Best Practices",id:"urdf-best-practices",level:4},{value:"URDF Tools and Validation",id:"urdf-tools-and-validation",level:4},{value:"Xacro for Complex Models",id:"xacro-for-complex-models",level:4},{value:"Code Examples",id:"code-examples",level:2},{value:"Python Agent with Joint State Subscriber",id:"python-agent-with-joint-state-subscriber",level:3},{value:"Controller Interface Node",id:"controller-interface-node",level:3},{value:"Advanced Python Agent with Action Client for Trajectory Execution",id:"advanced-python-agent-with-action-client-for-trajectory-execution",level:3},{value:"Python Agent with Controller State Monitoring",id:"python-agent-with-controller-state-monitoring",level:3},{value:"URDF Example - Simple Robot Arm",id:"urdf-example---simple-robot-arm",level:3},{value:"Python URDF Parser Example",id:"python-urdf-parser-example",level:3},{value:"Loading URDF from File and Working with Robot Description",id:"loading-urdf-from-file-and-working-with-robot-description",level:3},{value:"Working with robot_state_publisher and URDF",id:"working-with-robot_state_publisher-and-urdf",level:3},{value:"URDF with ros2_control Integration",id:"urdf-with-ros2_control-integration",level:3},{value:"Exercises",id:"exercises",level:2},{value:"References",id:"references",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"python-agent-integration-with-ros-controllers--urdf-modeling",children:"Python Agent Integration with ROS Controllers + URDF Modeling"})}),"\n",(0,r.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this week, students will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Integrate Python agents with ROS controllers for robot actuation"}),"\n",(0,r.jsx)(e.li,{children:"Understand the fundamentals of URDF (Unified Robot Description Format) modeling"}),"\n",(0,r.jsx)(e.li,{children:"Create and manipulate robot models using URDF"}),"\n",(0,r.jsx)(e.li,{children:"Implement control interfaces between Python agents and robot hardware"}),"\n",(0,r.jsx)(e.li,{children:"Simulate robot behavior using controller configurations"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(e.p,{children:"This week focuses on the integration of Python-based intelligent agents with ROS controllers and the creation of robot models using URDF (Unified Robot Description Format). This represents a critical step in robotics development, bridging high-level AI decision-making with low-level hardware control. Python agents provide the cognitive layer for decision-making, while ROS controllers manage the precise execution of commands on robot hardware."}),"\n",(0,r.jsx)(e.p,{children:"The combination of Python agents and ROS controllers enables sophisticated robot behaviors, from simple movement commands to complex manipulation tasks. URDF modeling provides the essential robot description that allows controllers to understand the robot's physical structure and kinematic properties."}),"\n",(0,r.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,r.jsx)(e.h3,{id:"python-agent-integration-with-ros-controllers",children:"Python Agent Integration with ROS Controllers"}),"\n",(0,r.jsx)(e.p,{children:"Python agents in robotics are software components that implement decision-making algorithms, planning systems, or AI-based control strategies. These agents must interface with ROS controllers, which handle the low-level hardware control and ensure precise execution of commands. The integration enables sophisticated robot behaviors by combining high-level cognitive capabilities with precise low-level control."}),"\n",(0,r.jsx)(e.h4,{id:"agent-controller-architecture",children:"Agent-Controller Architecture"}),"\n",(0,r.jsx)(e.p,{children:"The integration between Python agents and ROS controllers typically follows this layered pattern:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Agent Layer"}),": Implements high-level decision-making, planning, and reasoning using AI algorithms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Interface Layer"}),": Translates agent decisions into controller commands and handles communication protocols"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Controller Layer"}),": Executes precise hardware control based on received commands"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Hardware Layer"}),": Physical robot components that execute the actions"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"types-of-ros-controllers",children:"Types of ROS Controllers"}),"\n",(0,r.jsx)(e.p,{children:"ROS 2 supports several types of controllers for different control needs:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint Trajectory Controller"}),": Executes complete trajectories with position, velocity, and acceleration"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Position Controllers"}),": Simple position control for individual joints"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Velocity Controllers"}),": Velocity-based control for smooth motion"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Effort Controllers"}),": Direct torque/force control for precise force application"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Forward Command Controllers"}),": Forward desired states to hardware interfaces"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"control-interface-patterns",children:"Control Interface Patterns"}),"\n",(0,r.jsx)(e.p,{children:"There are several common patterns for integrating Python agents with ROS controllers:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Direct Command Pattern"}),": Agent sends immediate commands to controllers"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Trajectory Planning Pattern"}),": Agent plans complete trajectories and sends them to trajectory controllers"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Feedback Control Pattern"}),": Agent uses sensor feedback to adjust control commands"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"State Machine Pattern"}),": Agent implements complex behaviors through state transitions"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"communication-mechanisms",children:"Communication Mechanisms"}),"\n",(0,r.jsx)(e.p,{children:"Python agents communicate with controllers using several ROS 2 communication patterns:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Topics"}),": For continuous state publishing and command streaming"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Services"}),": For synchronous configuration and immediate actions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Actions"}),": For long-running tasks with progress feedback"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Parameters"}),": For dynamic configuration changes"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"python-agent-implementation-considerations",children:"Python Agent Implementation Considerations"}),"\n",(0,r.jsx)(e.p,{children:"When implementing Python agents for ROS controller integration, consider:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Real-time constraints"}),": Ensure control loop timing requirements are met"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Safety boundaries"}),": Implement safety checks and limits"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Error handling"}),": Gracefully handle controller failures and exceptions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"State management"}),": Maintain consistent state between agent and controllers"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Logging and diagnostics"}),": Track agent decisions and controller responses"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"ros2_control-framework-components",children:"ros2_control Framework Components"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.code,{children:"ros2_control"})," framework provides several key components for Python agent integration:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Hardware Interface"}),": Abstracts communication with specific hardware platforms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Controller Manager"}),": Manages the lifecycle of controllers (load, configure, start, stop)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Controller Types"}),": Pre-built controllers for common control tasks"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Transmission Interface"}),": Maps actuator commands to joint commands"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Resource Manager"}),": Tracks and manages hardware resources"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,r.jsx)(e.p,{children:"Controllers are configured using YAML files that specify parameters such as:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Joint names and mapping"}),"\n",(0,r.jsx)(e.li,{children:"Control frequency"}),"\n",(0,r.jsx)(e.li,{children:"Command and state interfaces"}),"\n",(0,r.jsx)(e.li,{children:"Controller-specific parameters"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Example controller configuration:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:"controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - joint1\n      - joint2\n      - joint3\n    command_interfaces:\n      - position\n    state_interfaces:\n      - position\n      - velocity\n"})}),"\n",(0,r.jsx)(e.h3,{id:"urdf-unified-robot-description-format",children:"URDF (Unified Robot Description Format)"}),"\n",(0,r.jsx)(e.p,{children:"URDF (Unified Robot Description Format) is an XML-based format used to describe robot models in ROS. It defines the robot's physical and kinematic properties, including links, joints, inertial properties, visual and collision models. URDF serves as the foundation for robot simulation, visualization, and kinematic analysis in ROS-based systems."}),"\n",(0,r.jsx)(e.h4,{id:"urdf-components-and-structure",children:"URDF Components and Structure"}),"\n",(0,r.jsx)(e.p,{children:"URDF documents have a hierarchical structure with several key components:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Links"}),": Rigid parts of the robot (e.g., base, arms, wheels) that have physical properties:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Visual"}),": How the link appears in simulation and visualization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Collision"}),": How the link interacts with the environment for physics simulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Inertial"}),": Physical properties like mass, center of mass, and inertia tensor"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Joints"}),": Connections between links that define the kinematic relationship:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint Types"}),": revolute (rotational), prismatic (linear), fixed, continuous, planar, floating"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint Limits"}),": Position, velocity, and effort limits for safety"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint Origins"}),": Position and orientation relative to parent link"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Materials"}),": Color and visual appearance definitions for rendering"]}),"\n",(0,r.jsx)(e.h4,{id:"urdf-xml-structure",children:"URDF XML Structure"}),"\n",(0,r.jsx)(e.p,{children:"A basic URDF follows this XML structure:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<robot name="robot_name">\n  \x3c!-- Define materials --\x3e\n  <material name="color_name">\n    <color rgba="r g b a"/>\n  </material>\n\n  \x3c!-- Define links --\x3e\n  <link name="link_name">\n    <visual>\n      <origin xyz="x y z" rpy="roll pitch yaw"/>\n      <geometry>\n        \x3c!-- Shape definition: box, cylinder, sphere, mesh --\x3e\n      </geometry>\n      <material name="material_name"/>\n    </visual>\n    <collision>\n      <origin xyz="x y z" rpy="roll pitch yaw"/>\n      <geometry>\n        \x3c!-- Shape definition --\x3e\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="mass_value"/>\n      <origin xyz="x y z" rpy="roll pitch yaw"/>\n      <inertia ixx="ixx" ixy="ixy" ixz="ixz" iyy="iyy" iyz="iyz" izz="izz"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Define joints --\x3e\n  <joint name="joint_name" type="joint_type">\n    <parent link="parent_link_name"/>\n    <child link="child_link_name"/>\n    <origin xyz="x y z" rpy="roll pitch yaw"/>\n    <axis xyz="x y z"/>  \x3c!-- For revolute and prismatic joints --\x3e\n    <limit lower="lower_limit" upper="upper_limit"\n           effort="max_effort" velocity="max_velocity"/>\n  </joint>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h4,{id:"joint-types-in-detail",children:"Joint Types in Detail"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Revolute"}),": Rotational joint with limited range of motion (like an elbow)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Continuous"}),": Rotational joint without limits (like a wheel)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Prismatic"}),": Linear sliding joint (like a piston)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fixed"}),": No movement, permanently connects two links"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Planar"}),": Movement in a plane"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Floating"}),": 6 DOF movement (no constraints)"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"geometry-types",children:"Geometry Types"}),"\n",(0,r.jsx)(e.p,{children:"URDF supports several geometric shapes for visual and collision models:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Box"}),': Defined by size="x_length y_width z_height"']}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cylinder"}),": Defined by radius and length"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sphere"}),": Defined by radius"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mesh"}),": Defined by filename and scale (for complex shapes)"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,r.jsx)(e.p,{children:"The inertial properties are crucial for accurate physics simulation:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mass"}),": The mass of the link in kilograms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Center of Mass"}),": The center of mass offset from the link origin"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Inertia Tensor"}),": 6 values representing the 3x3 inertia matrix (ixx, ixy, ixz, iyy, iyz, izz)"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"urdf-best-practices",children:"URDF Best Practices"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Naming Conventions"}),": Use descriptive, consistent names (e.g., ",(0,r.jsx)(e.code,{children:"base_link"}),", ",(0,r.jsx)(e.code,{children:"arm_link1"}),")"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Proper Inertial Properties"}),": Include realistic inertial values for accurate simulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Collision vs Visual"}),": Use simpler shapes for collision models to improve performance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Tree Structure"}),": Maintain a proper tree structure (no loops in the kinematic chain)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Origin Conventions"}),": Use consistent origin placements (e.g., at joint centers)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Xacro Usage"}),": For complex robots, use Xacro (XML Macros) to parameterize and reuse components"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"urdf-tools-and-validation",children:"URDF Tools and Validation"}),"\n",(0,r.jsx)(e.p,{children:"ROS provides several tools for working with URDF:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"check_urdf"}),": Validates URDF syntax and structure"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"urdf_to_graphiz"}),": Generates visual representation of the kinematic tree"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"robot_state_publisher"}),": Publishes transforms based on joint states"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"joint_state_publisher"}),": Publishes default joint states for visualization"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"xacro-for-complex-models",children:"Xacro for Complex Models"}),"\n",(0,r.jsx)(e.p,{children:"Xacro (XML Macros) extends URDF with features like:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Variables and constants"}),"\n",(0,r.jsx)(e.li,{children:"Mathematical expressions"}),"\n",(0,r.jsx)(e.li,{children:"Macros for reusable components"}),"\n",(0,r.jsx)(e.li,{children:"Include statements for modular design"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Example Xacro usage:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="robot_name">\n  \x3c!-- Define constants --\x3e\n  <xacro:property name="M_PI" value="3.14159"/>\n\n  \x3c!-- Define a macro for repeated components --\x3e\n  <xacro:macro name="simple_wheel" params="prefix parent xyz">\n    <joint name="${prefix}_wheel_joint" type="continuous">\n      <parent link="${parent}"/>\n      <child link="${prefix}_wheel_link"/>\n      <origin xyz="${xyz}" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n    </joint>\n\n    <link name="${prefix}_wheel_link">\n      <visual>\n        <geometry>\n          <cylinder radius="0.1" length="0.05"/>\n        </geometry>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder radius="0.1" length="0.05"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="0.5"/>\n        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.02"/>\n      </inertial>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Use the macro --\x3e\n  <xacro:simple_wheel prefix="front_left" parent="base_link" xyz="0.2 0.1 -0.05"/>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,r.jsx)(e.h3,{id:"python-agent-with-joint-state-subscriber",children:"Python Agent with Joint State Subscriber"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of a Python agent that subscribes to joint states:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom control_msgs.msg import JointTrajectoryControllerState\nimport numpy as np\n\nclass RobotAgentNode(Node):\n    def __init__(self):\n        super().__init__('robot_agent_node')\n\n        # Subscribe to joint states\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Publisher for joint commands\n        self.joint_command_publisher = self.create_publisher(\n            Float64MultiArray,\n            '/position_commands',\n            10\n        )\n\n        # Store current joint positions\n        self.current_positions = {}\n\n        # Timer for agent decision-making\n        self.timer = self.create_timer(0.1, self.agent_decision_callback)\n\n        self.get_logger().info('Robot Agent Node initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update current joint positions\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.current_positions[name] = msg.position[i]\n\n        self.get_logger().info(f'Updated joint positions: {self.current_positions}')\n\n    def agent_decision_callback(self):\n        \"\"\"Make decisions based on current state\"\"\"\n        # Example: Simple joint position control\n        if len(self.current_positions) > 0:\n            # Create target positions (example: slightly modify current positions)\n            target_positions = []\n            for joint_name, current_pos in self.current_positions.items():\n                # Add small adjustment based on some logic\n                target_pos = current_pos + 0.01  # Example adjustment\n                target_positions.append(target_pos)\n\n            # Publish command\n            command_msg = Float64MultiArray()\n            command_msg.data = target_positions\n            self.joint_command_publisher.publish(command_msg)\n\n            self.get_logger().info(f'Published joint commands: {target_positions}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    robot_agent_node = RobotAgentNode()\n\n    try:\n        rclpy.spin(robot_agent_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_agent_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"controller-interface-node",children:"Controller Interface Node"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of a Python node that interfaces with ROS controllers:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport time\n\nclass ControllerInterfaceNode(Node):\n    def __init__(self):\n        super().__init__('controller_interface_node')\n\n        # Publisher for trajectory commands\n        self.trajectory_publisher = self.create_publisher(\n            JointTrajectory,\n            '/joint_trajectory_controller/joint_trajectory',\n            10\n        )\n\n        # Timer to send trajectory commands\n        self.timer = self.create_timer(2.0, self.send_trajectory_command)\n\n        self.get_logger().info('Controller Interface Node initialized')\n\n    def send_trajectory_command(self):\n        \"\"\"Send a trajectory command to the controller\"\"\"\n        trajectory_msg = JointTrajectory()\n\n        # Define joint names (example for a simple robot)\n        trajectory_msg.joint_names = ['joint1', 'joint2', 'joint3']\n\n        # Create trajectory point\n        point = JointTrajectoryPoint()\n\n        # Set positions for each joint\n        point.positions = [0.5, 1.0, -0.5]  # Example positions in radians\n\n        # Set velocities (optional)\n        point.velocities = [0.0, 0.0, 0.0]\n\n        # Set accelerations (optional)\n        point.accelerations = [0.0, 0.0, 0.0]\n\n        # Set time from start\n        point.time_from_start = Duration(sec=1, nanosec=0)\n\n        # Add point to trajectory\n        trajectory_msg.points = [point]\n\n        # Publish trajectory\n        self.trajectory_publisher.publish(trajectory_msg)\n\n        self.get_logger().info(f'Published trajectory command: {point.positions}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller_interface_node = ControllerInterfaceNode()\n\n    try:\n        rclpy.spin(controller_interface_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller_interface_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"advanced-python-agent-with-action-client-for-trajectory-execution",children:"Advanced Python Agent with Action Client for Trajectory Execution"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of a more advanced Python agent using actions for trajectory execution:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nimport time\nimport math\n\nclass AdvancedRobotAgentNode(Node):\n    def __init__(self):\n        super().__init__(\'advanced_robot_agent_node\')\n\n        # Create action client for trajectory execution\n        self._action_client = ActionClient(\n            self,\n            FollowJointTrajectory,\n            \'joint_trajectory_controller/follow_joint_trajectory\'\n        )\n\n        # Timer for agent decision-making\n        self.timer = self.create_timer(5.0, self.execute_trajectory_callback)\n\n        self.get_logger().info(\'Advanced Robot Agent Node initialized\')\n\n    def execute_trajectory_callback(self):\n        """Execute a planned trajectory using action client"""\n        goal_msg = FollowJointTrajectory.Goal()\n\n        # Define joint names\n        goal_msg.trajectory.joint_names = [\'joint1\', \'joint2\', \'joint3\']\n\n        # Create trajectory points\n        point1 = JointTrajectoryPoint()\n        point1.positions = [0.0, 0.0, 0.0]\n        point1.velocities = [0.0, 0.0, 0.0]\n        point1.time_from_start = Duration(sec=1, nanosec=0)\n\n        point2 = JointTrajectoryPoint()\n        point2.positions = [0.5, 0.5, 0.5]\n        point2.velocities = [0.0, 0.0, 0.0]\n        point2.time_from_start = Duration(sec=2, nanosec=0)\n\n        point3 = JointTrajectoryPoint()\n        point3.positions = [0.0, 0.0, 0.0]  # Return to start\n        point3.velocities = [0.0, 0.0, 0.0]\n        point3.time_from_start = Duration(sec=3, nanosec=0)\n\n        goal_msg.trajectory.points = [point1, point2, point3]\n\n        self._send_goal_async(goal_msg)\n\n    def _send_goal_async(self, goal_msg):\n        """Send goal to trajectory controller"""\n        self.get_logger().info(\'Waiting for action server...\')\n\n        if not self._action_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error(\'Action server not available\')\n            return\n\n        future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        """Handle goal response"""\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\'Goal rejected\')\n            return\n\n        self.get_logger().info(\'Goal accepted\')\n\n        get_result_future = goal_handle.get_result_async()\n        get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        """Handle result of trajectory execution"""\n        result = future.result().result\n        self.get_logger().info(f\'Trajectory execution result: {result.error_code}\')\n\n    def feedback_callback(self, feedback_msg):\n        """Handle feedback during trajectory execution"""\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f\'Trajectory progress: {feedback.joint_names}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    advanced_agent_node = AdvancedRobotAgentNode()\n\n    try:\n        rclpy.spin(advanced_agent_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        advanced_agent_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsx)(e.h3,{id:"python-agent-with-controller-state-monitoring",children:"Python Agent with Controller State Monitoring"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of a Python agent that monitors controller states:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom control_msgs.msg import JointTrajectoryControllerState\nfrom controller_manager_msgs.srv import ListControllers\nimport time\n\nclass ControllerMonitoringAgent(Node):\n    def __init__(self):\n        super().__init__('controller_monitoring_agent')\n\n        # Subscribe to controller state\n        self.controller_state_subscriber = self.create_subscription(\n            JointTrajectoryControllerState,\n            '/joint_trajectory_controller/state',\n            self.controller_state_callback,\n            10\n        )\n\n        # Create service client to list controllers\n        self.list_controllers_client = self.create_client(\n            ListControllers,\n            '/controller_manager/list_controllers'\n        )\n\n        # Timer for controller monitoring\n        self.timer = self.create_timer(1.0, self.monitor_controllers)\n\n        self.get_logger().info('Controller Monitoring Agent initialized')\n\n    def controller_state_callback(self, msg):\n        \"\"\"Handle controller state updates\"\"\"\n        self.get_logger().info(f'Controller state received')\n        self.get_logger().info(f'Joint names: {msg.joint_names}')\n        self.get_logger().info(f'Position: {msg.feedback.positions}')\n        self.get_logger().info(f'Velocity: {msg.feedback.velocities}')\n        self.get_logger().info(f'Effort: {msg.feedback.effort}')\n\n    def monitor_controllers(self):\n        \"\"\"Monitor controller status\"\"\"\n        if self.list_controllers_client.service_is_ready():\n            request = ListControllers.Request()\n            future = self.list_controllers_client.call_async(request)\n            future.add_done_callback(self.controllers_list_callback)\n\n    def controllers_list_callback(self, future):\n        \"\"\"Handle controllers list response\"\"\"\n        try:\n            response = future.result()\n            for controller in response.controller:\n                self.get_logger().info(\n                    f'Controller: {controller.name}, '\n                    f'State: {controller.state}, '\n                    f'Type: {controller.type}'\n                )\n        except Exception as e:\n            self.get_logger().error(f'Error getting controllers list: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    controller_agent = ControllerMonitoringAgent()\n\n    try:\n        rclpy.spin(controller_agent)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller_agent.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"urdf-example---simple-robot-arm",children:"URDF Example - Simple Robot Arm"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example URDF file for a simple robot arm:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot_arm" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Materials --\x3e\n  <material name="black">\n    <color rgba="0.0 0.0 0.0 1.0"/>\n  </material>\n  <material name="red">\n    <color rgba="0.8 0.0 0.0 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.2"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.1" radius="0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- First Joint and Link --\x3e\n  <joint name="joint1" type="revolute">\n    <parent link="base_link"/>\n    <child link="link1"/>\n    <origin xyz="0.0 0.0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-3.14" upper="3.14" effort="100" velocity="1.0"/>\n  </joint>\n\n  <link name="link1">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n      <material name="red"/>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Second Joint and Link --\x3e\n  <joint name="joint2" type="revolute">\n    <parent link="link1"/>\n    <child link="link2"/>\n    <origin xyz="0.0 0.0 0.15" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>\n  </joint>\n\n  <link name="link2">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.2"/>\n      </geometry>\n      <material name="black"/>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.05 0.05 0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.3"/>\n      <inertia ixx="0.0005" ixy="0.0" ixz="0.0" iyy="0.0005" iyz="0.0" izz="0.0005"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Third Joint and Link --\x3e\n  <joint name="joint3" type="revolute">\n    <parent link="link2"/>\n    <child link="end_effector"/>\n    <origin xyz="0.0 0.0 0.1" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-3.14" upper="3.14" effort="100" velocity="1.0"/>\n  </joint>\n\n  <link name="end_effector">\n    <visual>\n      <geometry>\n        <sphere radius="0.02"/>\n      </geometry>\n      <material name="red"/>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.02"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n    </inertial>\n  </link>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"python-urdf-parser-example",children:"Python URDF Parser Example"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of how to work with URDF in Python:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nimport xml.etree.ElementTree as ET\n\nclass URDFAnalyzerNode(Node):\n    def __init__(self):\n        super().__init__(\'urdf_analyzer_node\')\n\n        self.get_logger().info(\'URDF Analyzer Node initialized\')\n\n        # Example URDF content (in practice, this would be loaded from a file)\n        self.example_urdf = \'\'\'<?xml version="1.0"?>\n<robot name="simple_robot_arm">\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.2"/>\n      </geometry>\n    </visual>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n  <joint name="joint1" type="revolute">\n    <parent link="base_link"/>\n    <child link="link1"/>\n    <origin xyz="0.0 0.0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-3.14" upper="3.14" effort="100" velocity="1.0"/>\n  </joint>\n  <link name="link1">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n    </visual>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n</robot>\'\'\'\n\n        # Parse the URDF\n        self.parse_urdf()\n\n    def parse_urdf(self):\n        """Parse the URDF and extract information"""\n        try:\n            root = ET.fromstring(self.example_urdf)\n\n            robot_name = root.attrib.get(\'name\', \'unknown\')\n            self.get_logger().info(f\'Robot name: {robot_name}\')\n\n            # Count links and joints\n            links = root.findall(\'link\')\n            joints = root.findall(\'joint\')\n\n            self.get_logger().info(f\'Number of links: {len(links)}\')\n            self.get_logger().info(f\'Number of joints: {len(joints)}\')\n\n            # Print link names\n            for link in links:\n                link_name = link.attrib.get(\'name\')\n                self.get_logger().info(f\'Link: {link_name}\')\n\n            # Print joint names and types\n            for joint in joints:\n                joint_name = joint.attrib.get(\'name\')\n                joint_type = joint.attrib.get(\'type\')\n                self.get_logger().info(f\'Joint: {joint_name}, Type: {joint_type}\')\n\n        except ET.ParseError as e:\n            self.get_logger().error(f\'Error parsing URDF: {e}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    urdf_analyzer_node = URDFAnalyzerNode()\n\n    try:\n        # Process URDF once\n        rclpy.spin_once(urdf_analyzer_node, timeout_sec=1.0)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        urdf_analyzer_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsx)(e.h3,{id:"loading-urdf-from-file-and-working-with-robot-description",children:"Loading URDF from File and Working with Robot Description"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of how to load a URDF file and work with the robot_description parameter in ROS 2:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rcl_interfaces.msg import ParameterType\nimport xml.etree.ElementTree as ET\n\nclass URDFLoaderNode(Node):\n    def __init__(self):\n        super().__init__('urdf_loader_node')\n\n        # Declare parameter for URDF file path\n        self.declare_parameter('urdf_file_path', '/path/to/robot.urdf')\n\n        # Get URDF file path from parameters\n        self.urdf_file_path = self.get_parameter('urdf_file_path').value\n\n        self.get_logger().info(f'Loading URDF from: {self.urdf_file_path}')\n\n        # Load and parse URDF\n        self.robot_description = self.load_urdf_file(self.urdf_file_path)\n\n        if self.robot_description:\n            # Set robot_description parameter for other nodes to use\n            robot_desc_param = rclpy.Parameter(\n                'robot_description',\n                ParameterType.PARAMETER_STRING,\n                self.robot_description\n            )\n            self.set_parameters([robot_desc_param])\n\n            self.get_logger().info('URDF loaded and robot_description parameter set')\n\n            # Analyze the URDF structure\n            self.analyze_urdf(self.robot_description)\n        else:\n            self.get_logger().error('Failed to load URDF file')\n\n    def load_urdf_file(self, file_path):\n        \"\"\"Load URDF content from file\"\"\"\n        try:\n            with open(file_path, 'r') as file:\n                urdf_content = file.read()\n            return urdf_content\n        except FileNotFoundError:\n            self.get_logger().error(f'URDF file not found: {file_path}')\n            return None\n        except Exception as e:\n            self.get_logger().error(f'Error reading URDF file: {e}')\n            return None\n\n    def analyze_urdf(self, urdf_string):\n        \"\"\"Analyze URDF structure and extract key information\"\"\"\n        try:\n            root = ET.fromstring(urdf_string)\n\n            # Extract robot name\n            robot_name = root.attrib.get('name', 'unknown_robot')\n            self.get_logger().info(f'Robot Name: {robot_name}')\n\n            # Extract all links\n            links = root.findall('link')\n            self.get_logger().info(f'Total Links: {len(links)}')\n\n            for link in links:\n                link_name = link.attrib.get('name')\n                # Check for visual, collision, and inertial elements\n                has_visual = len(link.findall('visual')) > 0\n                has_collision = len(link.findall('collision')) > 0\n                has_inertial = len(link.findall('inertial')) > 0\n\n                self.get_logger().info(\n                    f'  Link: {link_name}, '\n                    f'Visual: {has_visual}, '\n                    f'Collision: {has_collision}, '\n                    f'Inertial: {has_inertial}'\n                )\n\n            # Extract all joints\n            joints = root.findall('joint')\n            self.get_logger().info(f'Total Joints: {len(joints)}')\n\n            for joint in joints:\n                joint_name = joint.attrib.get('name')\n                joint_type = joint.attrib.get('type')\n                parent_link = joint.find('parent').attrib.get('link') if joint.find('parent') is not None else 'None'\n                child_link = joint.find('child').attrib.get('link') if joint.find('child') is not None else 'None'\n\n                self.get_logger().info(\n                    f'  Joint: {joint_name}, '\n                    f'Type: {joint_type}, '\n                    f'Parent: {parent_link}, '\n                    f'Child: {child_link}'\n                )\n\n        except ET.ParseError as e:\n            self.get_logger().error(f'Error parsing URDF: {e}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    urdf_loader_node = URDFLoaderNode()\n\n    try:\n        # Keep the node running to maintain the robot_description parameter\n        rclpy.spin(urdf_loader_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        urdf_loader_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"working-with-robot_state_publisher-and-urdf",children:"Working with robot_state_publisher and URDF"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of how to work with robot_state_publisher to publish transforms based on URDF:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformBroadcaster\nfrom geometry_msgs.msg import TransformStamped\nimport math\n\nclass RobotStatePublisherNode(Node):\n    def __init__(self):\n        super().__init__('robot_state_publisher')\n\n        # Subscribe to joint states\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Create transform broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n\n        # Store joint states\n        self.joint_states = {}\n\n        # Timer for publishing transforms\n        self.timer = self.create_timer(0.05, self.publish_transforms)  # 20 Hz\n\n        self.get_logger().info('Robot State Publisher initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update joint states from JointState message\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_states[name] = msg.position[i]\n\n    def publish_transforms(self):\n        \"\"\"Publish transforms based on joint states and URDF structure\"\"\"\n        # This is a simplified example - in practice, you would calculate\n        # transforms based on the URDF kinematic chain\n\n        # Example: Publish transform for a simple 3-DOF arm\n        transforms = []\n\n        # Base to Link 1 transform (assuming fixed)\n        t1 = TransformStamped()\n        t1.header.stamp = self.get_clock().now().to_msg()\n        t1.header.frame_id = 'base_link'\n        t1.child_frame_id = 'link1'\n        t1.transform.translation.x = 0.0\n        t1.transform.translation.y = 0.0\n        t1.transform.translation.z = 0.05  # Height of first joint\n        t1.transform.rotation.x = 0.0\n        t1.transform.rotation.y = 0.0\n        t1.transform.rotation.z = 0.0\n        t1.transform.rotation.w = 1.0\n        transforms.append(t1)\n\n        # Link 1 to Link 2 transform (with joint1 rotation)\n        if 'joint1' in self.joint_states:\n            joint1_pos = self.joint_states['joint1']\n\n            t2 = TransformStamped()\n            t2.header.stamp = self.get_clock().now().to_msg()\n            t2.header.frame_id = 'link1'\n            t2.child_frame_id = 'link2'\n            t2.transform.translation.x = 0.0  # Length of link1 along z-axis\n            t2.transform.translation.y = 0.0\n            t2.transform.translation.z = 0.15  # Length of link1\n            # Apply rotation around Z-axis for joint1\n            t2.transform.rotation.x = 0.0\n            t2.transform.rotation.y = 0.0\n            t2.transform.rotation.z = math.sin(joint1_pos / 2.0)\n            t2.transform.rotation.w = math.cos(joint1_pos / 2.0)\n            transforms.append(t2)\n\n        # Broadcast all transforms\n        for transform in transforms:\n            self.tf_broadcaster.sendTransform(transform)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    robot_state_publisher = RobotStatePublisherNode()\n\n    try:\n        rclpy.spin(robot_state_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_state_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"urdf-with-ros2_control-integration",children:"URDF with ros2_control Integration"}),"\n",(0,r.jsx)(e.p,{children:"Here's an example of how to integrate URDF with ros2_control for hardware interface:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="robot_with_control" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Import ros2_control xacro macros --\x3e\n  <xacro:include filename="$(find my_robot_description)/urdf/my_robot.ros2_control.xacro"/>\n\n  \x3c!-- Define materials --\x3e\n  <material name="black">\n    <color rgba="0.0 0.0 0.0 1.0"/>\n  </material>\n  <material name="red">\n    <color rgba="0.8 0.0 0.0 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.2"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.1" radius="0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joint 1 --\x3e\n  <joint name="joint1" type="revolute">\n    <parent link="base_link"/>\n    <child link="link1"/>\n    <origin xyz="0.0 0.0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-3.14" upper="3.14" effort="100" velocity="1.0"/>\n  </joint>\n\n  <link name="link1">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n      <material name="red"/>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- ros2_control hardware interface --\x3e\n  <ros2_control name="GazeboSystem" type="system">\n    <hardware>\n      <plugin>gazebo_ros2_control/GazeboSystem</plugin>\n    </hardware>\n    <joint name="joint1">\n      <command_interface name="position">\n        <param name="min">-3.14</param>\n        <param name="max">3.14</param>\n      </command_interface>\n      <command_interface name="velocity">\n        <param name="min">-1.0</param>\n        <param name="max">1.0</param>\n      </command_interface>\n      <state_interface name="position"/>\n      <state_interface name="velocity"/>\n    </joint>\n  </ros2_control>\n\n  \x3c!-- Controller manager configuration --\x3e\n  <gazebo>\n    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control::GazeboROS2ControlPlugin">\n      <parameters>$(find my_robot_bringup)/config/controllers.yaml</parameters>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Create a Python agent that moves a simulated robot arm to a specific position"}),"\n",(0,r.jsx)(e.li,{children:"Design a URDF model for a simple mobile robot with differential drive"}),"\n",(0,r.jsx)(e.li,{children:"Implement a controller interface that handles position, velocity, and effort commands"}),"\n",(0,r.jsx)(e.li,{children:"Extend the URDF example to include a gripper at the end effector"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["ROS 2 Control Documentation: ",(0,r.jsx)(e.a,{href:"https://control.ros.org/",children:"https://control.ros.org/"})]}),"\n",(0,r.jsxs)(e.li,{children:["URDF Tutorials: ",(0,r.jsx)(e.a,{href:"http://wiki.ros.org/urdf/Tutorials",children:"http://wiki.ros.org/urdf/Tutorials"})]}),"\n",(0,r.jsxs)(e.li,{children:["ROS 2 Controller Manager: ",(0,r.jsx)(e.a,{href:"https://github.com/ros-controls/ros2_control",children:"https://github.com/ros-controls/ros2_control"})]}),"\n",(0,r.jsxs)(e.li,{children:["Xacro Documentation: ",(0,r.jsx)(e.a,{href:"http://wiki.ros.org/xacro",children:"http://wiki.ros.org/xacro"})]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>l});var o=t(6540);const r={},i=o.createContext(r);function s(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);