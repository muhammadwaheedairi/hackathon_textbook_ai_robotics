<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-module-2-digital-twin/week-5-high-fidelity-rendering-in-unity" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">High-Fidelity Rendering in Unity | AI-Native Textbook Physical AI &amp; Humanoid Robotics</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="theme-color" content="#12affa"><meta data-rh="true" name="keywords" content="robotics, AI, textbook, ROS 2, Gazebo, NVIDIA Isaac, humanoid robotics, physical AI, education"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="High-Fidelity Rendering in Unity | AI-Native Textbook Physical AI &amp; Humanoid Robotics"><meta data-rh="true" name="description" content="Learning Objectives"><meta data-rh="true" property="og:description" content="Learning Objectives"><link data-rh="true" rel="icon" href="/hackathon_textbook_ai_robotics/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity"><link data-rh="true" rel="alternate" href="https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity" hreflang="en"><link data-rh="true" rel="alternate" href="https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Week 5: High-Fidelity Rendering in Unity","item":"https://muhammadwaheedairi.github.io/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity"}]}</script><link rel="alternate" type="application/rss+xml" href="/hackathon_textbook_ai_robotics/blog/rss.xml" title="AI-Native Textbook Physical AI &amp; Humanoid Robotics RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/hackathon_textbook_ai_robotics/blog/atom.xml" title="AI-Native Textbook Physical AI &amp; Humanoid Robotics Atom Feed"><link rel="stylesheet" href="/hackathon_textbook_ai_robotics/assets/css/styles.a4deca95.css">
<script src="/hackathon_textbook_ai_robotics/assets/js/runtime~main.2e70f2f4.js" defer="defer"></script>
<script src="/hackathon_textbook_ai_robotics/assets/js/main.1c7b6568.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/hackathon_textbook_ai_robotics/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/hackathon_textbook_ai_robotics/"><div class="navbar__logo"><img src="/hackathon_textbook_ai_robotics/img/logo.svg" alt="AI-Native Textbook Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/hackathon_textbook_ai_robotics/img/logo.svg" alt="AI-Native Textbook Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">AI-Native Textbook</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/hackathon_textbook_ai_robotics/docs/quickstart">Textbook</a><a class="navbar__item navbar__link" href="/hackathon_textbook_ai_robotics/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/muhammadwaheedairi/hackathon_textbook_ai_robotics" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="search-bar-wrapper"><div style="width:100%;display:flex;justify-content:center;padding:1rem 0;background-color:var(--ifm-background-surface-color);border-bottom:1px solid var(--ifm-toc-border-color)"><div style="width:100%;max-width:1200px;padding-left:1rem;padding-right:1rem"><div class="search-bar-container"><div class="search-input-wrapper"><input type="text" class="search-input" placeholder="Search textbook content..." aria-label="Search textbook content" aria-autocomplete="list" aria-controls="search-results-list" aria-expanded="false" value=""></div></div></div></div></div><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/hackathon_textbook_ai_robotics/docs/quickstart"><span title="Getting Started" class="categoryLinkLabel_W154">Getting Started</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/quickstart"><span title="Quick Start Guide" class="linkLabel_WmDU">Quick Start Guide</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-1-introduction-to-physical-ai"><span title="Module 1 — The Robotic Nervous System (ROS 2)" class="categoryLinkLabel_W154">Module 1 — The Robotic Nervous System (ROS 2)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-1-introduction-to-physical-ai"><span title="Week 1: Introduction to Physical AI and Sensors" class="linkLabel_WmDU">Week 1: Introduction to Physical AI and Sensors</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-2-ros-2-fundamentals"><span title="Week 2: ROS 2 Fundamentals — Nodes, Topics, Services, Packages" class="linkLabel_WmDU">Week 2: ROS 2 Fundamentals — Nodes, Topics, Services, Packages</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-1-robotic-nervous-system/week-3-python-agent-integration"><span title="Week 3: Python Agent Integration with ROS Controllers + URDF Modeling" class="linkLabel_WmDU">Week 3: Python Agent Integration with ROS Controllers + URDF Modeling</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo"><span title="Module 2 — Digital Twin (Gazebo &amp; Unity)" class="categoryLinkLabel_W154">Module 2 — Digital Twin (Gazebo &amp; Unity)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo"><span title="Week 4: Physics Simulation in Gazebo" class="linkLabel_WmDU">Week 4: Physics Simulation in Gazebo</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity"><span title="Week 5: High-Fidelity Rendering in Unity" class="linkLabel_WmDU">Week 5: High-Fidelity Rendering in Unity</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/hackathon_textbook_ai_robotics/docs/module-3-ai-robot-brain/week-6-nvidia-isaac-sim"><span title="Module 3 — The AI-Robot Brain (NVIDIA Isaac™)" class="categoryLinkLabel_W154">Module 3 — The AI-Robot Brain (NVIDIA Isaac™)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-3-ai-robot-brain/week-6-nvidia-isaac-sim"><span title="Week 6 - NVIDIA Isaac Sim" class="linkLabel_WmDU">Week 6 - NVIDIA Isaac Sim</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-3-ai-robot-brain/week-7-isaac-ros-hardware-accelerated"><span title="Week 7 - Isaac ROS Hardware Accelerated" class="linkLabel_WmDU">Week 7 - Isaac ROS Hardware Accelerated</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-3-ai-robot-brain/week-8-isaac-sim-reinforcement-learning"><span title="Week 8 - Isaac Sim Reinforcement Learning" class="linkLabel_WmDU">Week 8 - Isaac Sim Reinforcement Learning</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="true" href="/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/week-9-voice-to-action-with-openai-whisper"><span title="Module 4 — Vision-Language-Action (VLA)" class="categoryLinkLabel_W154">Module 4 — Vision-Language-Action (VLA)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/week-9-voice-to-action-with-openai-whisper"><span title="Week 9 - Voice-to-Action with OpenAI Whisper" class="linkLabel_WmDU">Week 9 - Voice-to-Action with OpenAI Whisper</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/week-10-cognitive-planning"><span title="Week 10 - Cognitive Planning with LLMs" class="linkLabel_WmDU">Week 10 - Cognitive Planning with LLMs</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hackathon_textbook_ai_robotics/docs/module-4-vision-language-action/week-11-13-capstone-autonomous-humanoid"><span title="Week 11-13 - Capstone Autonomous Humanoid" class="linkLabel_WmDU">Week 11-13 - Capstone Autonomous Humanoid</span></a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/hackathon_textbook_ai_robotics/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Module 2 — Digital Twin (Gazebo &amp; Unity)</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Week 5: High-Fidelity Rendering in Unity</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>High-Fidelity Rendering in Unity</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="learning-objectives">Learning Objectives<a href="#learning-objectives" class="hash-link" aria-label="Direct link to Learning Objectives" title="Direct link to Learning Objectives" translate="no">​</a></h2>
<p>By the end of this week, students will be able to:</p>
<ul>
<li class="">Understand the fundamentals of high-fidelity rendering in Unity</li>
<li class="">Configure Unity for photorealistic visualization</li>
<li class="">Implement advanced lighting and material systems</li>
<li class="">Integrate Unity with robotics simulation frameworks</li>
<li class="">Create realistic sensor simulation in Unity environments</li>
<li class="">Optimize rendering performance for real-time applications</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction" translate="no">​</a></h2>
<p>High-fidelity rendering in Unity has become increasingly important for robotics applications, particularly for creating realistic training environments for AI systems and simulating sensor data with photorealistic quality. Unity&#x27;s advanced rendering pipeline, including the High Definition Render Pipeline (HDRP) and Universal Render Pipeline (URP), enables the creation of photorealistic environments that can be used for synthetic data generation, sensor simulation, and human-in-the-loop testing. This week explores the fundamentals of high-fidelity rendering in Unity and its applications in robotics simulation.</p>
<p>Unity&#x27;s rendering capabilities have evolved significantly, offering features like real-time ray tracing, physically-based rendering (PBR), global illumination, and advanced post-processing effects. These features make Unity an excellent platform for creating realistic digital twins of physical environments, which are essential for training robust perception systems in robotics. The integration of Unity with robotics frameworks enables seamless transfer of simulated data to real-world applications.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="theory">Theory<a href="#theory" class="hash-link" aria-label="Direct link to Theory" title="Direct link to Theory" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-rendering-pipelines">Unity Rendering Pipelines<a href="#unity-rendering-pipelines" class="hash-link" aria-label="Direct link to Unity Rendering Pipelines" title="Direct link to Unity Rendering Pipelines" translate="no">​</a></h3>
<p>Unity offers three main rendering pipelines optimized for different use cases:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="built-in-render-pipeline">Built-in Render Pipeline<a href="#built-in-render-pipeline" class="hash-link" aria-label="Direct link to Built-in Render Pipeline" title="Direct link to Built-in Render Pipeline" translate="no">​</a></h4>
<p>The legacy rendering pipeline that offers basic rendering capabilities and is suitable for simple applications. While still functional, it lacks many of the advanced features available in the newer pipelines.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="universal-render-pipeline-urp">Universal Render Pipeline (URP)<a href="#universal-render-pipeline-urp" class="hash-link" aria-label="Direct link to Universal Render Pipeline (URP)" title="Direct link to Universal Render Pipeline (URP)" translate="no">​</a></h4>
<p>A lightweight, flexible rendering pipeline designed for performance across a wide range of platforms. URP provides a good balance between visual quality and performance, making it suitable for mobile robotics applications and applications requiring high frame rates.</p>
<p>Key features of URP:</p>
<ul>
<li class="">Lightweight and efficient</li>
<li class="">Supports 2D and 3D rendering</li>
<li class="">Customizable render passes</li>
<li class="">Built-in post-processing effects</li>
<li class="">Shader Graph integration</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="high-definition-render-pipeline-hdrp">High Definition Render Pipeline (HDRP)<a href="#high-definition-render-pipeline-hdrp" class="hash-link" aria-label="Direct link to High Definition Render Pipeline (HDRP)" title="Direct link to High Definition Render Pipeline (HDRP)" translate="no">​</a></h4>
<p>A state-of-the-art rendering pipeline designed for high-fidelity visuals on powerful hardware. HDRP is ideal for applications requiring photorealistic rendering, such as digital twin creation and high-quality sensor simulation.</p>
<p>Key features of HDRP:</p>
<ul>
<li class="">Physically-based rendering</li>
<li class="">Real-time ray tracing</li>
<li class="">Advanced lighting models</li>
<li class="">Global illumination (Baked and realtime)</li>
<li class="">Volumetric effects</li>
<li class="">Advanced post-processing stack</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="physically-based-rendering-pbr">Physically-Based Rendering (PBR)<a href="#physically-based-rendering-pbr" class="hash-link" aria-label="Direct link to Physically-Based Rendering (PBR)" title="Direct link to Physically-Based Rendering (PBR)" translate="no">​</a></h3>
<p>Physically-Based Rendering is a methodology that simulates light-object interactions using real-world physics principles. PBR materials in Unity are defined by several key properties:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="albedo-base-color">Albedo (Base Color)<a href="#albedo-base-color" class="hash-link" aria-label="Direct link to Albedo (Base Color)" title="Direct link to Albedo (Base Color)" translate="no">​</a></h4>
<p>The base color of the material without lighting considerations. This represents the color of the surface when illuminated by white light.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="metallic">Metallic<a href="#metallic" class="hash-link" aria-label="Direct link to Metallic" title="Direct link to Metallic" translate="no">​</a></h4>
<p>Controls whether a surface behaves like a metal or a non-metal. Metallic surfaces reflect light as colored reflections, while non-metallic surfaces reflect light as white highlights.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="smoothnessroughness">Smoothness/Roughness<a href="#smoothnessroughness" class="hash-link" aria-label="Direct link to Smoothness/Roughness" title="Direct link to Smoothness/Roughness" translate="no">​</a></h4>
<p>Controls the microsurface detail of the material, affecting how light scatters. Smooth surfaces create sharp reflections, while rough surfaces create diffuse reflections.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="normal-maps">Normal Maps<a href="#normal-maps" class="hash-link" aria-label="Direct link to Normal Maps" title="Direct link to Normal Maps" translate="no">​</a></h4>
<p>Provide detailed surface geometry information without increasing polygon count. Normal maps create the illusion of complex surface details like scratches, bumps, and grooves.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="occlusion-maps">Occlusion Maps<a href="#occlusion-maps" class="hash-link" aria-label="Direct link to Occlusion Maps" title="Direct link to Occlusion Maps" translate="no">​</a></h4>
<p>Simulate the shadowing effect of small surface details, enhancing the perception of depth and contact between surfaces.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lighting-systems-in-unity">Lighting Systems in Unity<a href="#lighting-systems-in-unity" class="hash-link" aria-label="Direct link to Lighting Systems in Unity" title="Direct link to Lighting Systems in Unity" translate="no">​</a></h3>
<p>Unity provides several lighting systems that can be used to create realistic illumination:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="real-time-lighting">Real-time Lighting<a href="#real-time-lighting" class="hash-link" aria-label="Direct link to Real-time Lighting" title="Direct link to Real-time Lighting" translate="no">​</a></h4>
<p>Lights that affect objects dynamically during gameplay. Real-time lighting provides interactive illumination but can be computationally expensive.</p>
<p>Types of real-time lights:</p>
<ul>
<li class="">Directional lights: Simulate distant light sources like the sun</li>
<li class="">Point lights: Emit light in all directions from a point</li>
<li class="">Spot lights: Emit light in a cone shape</li>
<li class="">Area lights: Emit light from a surface area (baked only in some pipelines)</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="baked-lighting">Baked Lighting<a href="#baked-lighting" class="hash-link" aria-label="Direct link to Baked Lighting" title="Direct link to Baked Lighting" translate="no">​</a></h4>
<p>Lighting that is precomputed and stored in lightmaps. Baked lighting provides high-quality global illumination but cannot change at runtime.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="mixed-lighting">Mixed Lighting<a href="#mixed-lighting" class="hash-link" aria-label="Direct link to Mixed Lighting" title="Direct link to Mixed Lighting" translate="no">​</a></h4>
<p>Combines real-time and baked lighting, allowing for static lighting to be baked while enabling dynamic shadows from moving objects.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-sensor-simulation">Unity Sensor Simulation<a href="#unity-sensor-simulation" class="hash-link" aria-label="Direct link to Unity Sensor Simulation" title="Direct link to Unity Sensor Simulation" translate="no">​</a></h3>
<p>Unity can simulate various sensor types used in robotics, providing realistic sensor data for testing and training:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="camera-simulation">Camera Simulation<a href="#camera-simulation" class="hash-link" aria-label="Direct link to Camera Simulation" title="Direct link to Camera Simulation" translate="no">​</a></h4>
<p>Unity&#x27;s camera components can simulate various camera types:</p>
<ul>
<li class="">RGB cameras for visual perception</li>
<li class="">Depth cameras for 3D reconstruction</li>
<li class="">Semantic segmentation cameras for object recognition</li>
<li class="">Stereo cameras for depth perception</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="lidar-simulation">LIDAR Simulation<a href="#lidar-simulation" class="hash-link" aria-label="Direct link to LIDAR Simulation" title="Direct link to LIDAR Simulation" translate="no">​</a></h4>
<p>LIDAR sensors can be simulated using raycasting techniques, providing accurate distance measurements and point cloud data similar to real LIDAR sensors.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="imu-simulation">IMU Simulation<a href="#imu-simulation" class="hash-link" aria-label="Direct link to IMU Simulation" title="Direct link to IMU Simulation" translate="no">​</a></h4>
<p>Inertial measurement units can be simulated by tracking the acceleration and rotation of objects in the Unity scene, providing realistic IMU data for navigation algorithms.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-robotics-integration">Unity Robotics Integration<a href="#unity-robotics-integration" class="hash-link" aria-label="Direct link to Unity Robotics Integration" title="Direct link to Unity Robotics Integration" translate="no">​</a></h3>
<p>Unity provides several tools and packages for robotics integration:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-robotics-hub">Unity Robotics Hub<a href="#unity-robotics-hub" class="hash-link" aria-label="Direct link to Unity Robotics Hub" title="Direct link to Unity Robotics Hub" translate="no">​</a></h4>
<p>A collection of tools and packages that facilitate robotics development in Unity, including:</p>
<ul>
<li class="">ROS# for ROS communication</li>
<li class="">ML-Agents for reinforcement learning</li>
<li class="">Unity Perception for synthetic data generation</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-simulation-framework">Unity Simulation Framework<a href="#unity-simulation-framework" class="hash-link" aria-label="Direct link to Unity Simulation Framework" title="Direct link to Unity Simulation Framework" translate="no">​</a></h4>
<p>The framework enables the creation of complex simulation environments with realistic physics and rendering, allowing for comprehensive testing of robotics algorithms.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="asset-packages-for-robotics">Asset Packages for Robotics<a href="#asset-packages-for-robotics" class="hash-link" aria-label="Direct link to Asset Packages for Robotics" title="Direct link to Asset Packages for Robotics" translate="no">​</a></h4>
<p>Unity provides specialized asset packages for robotics simulation, including:</p>
<ul>
<li class="">Procedural environment generation</li>
<li class="">Physics-based robot models</li>
<li class="">Sensor simulation tools</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="performance-optimization-for-real-time-rendering">Performance Optimization for Real-Time Rendering<a href="#performance-optimization-for-real-time-rendering" class="hash-link" aria-label="Direct link to Performance Optimization for Real-Time Rendering" title="Direct link to Performance Optimization for Real-Time Rendering" translate="no">​</a></h3>
<p>High-fidelity rendering can be computationally intensive. Several optimization strategies help maintain performance:</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="level-of-detail-lod">Level of Detail (LOD)<a href="#level-of-detail-lod" class="hash-link" aria-label="Direct link to Level of Detail (LOD)" title="Direct link to Level of Detail (LOD)" translate="no">​</a></h4>
<p>Implementing multiple levels of detail for 3D models allows the renderer to use simpler representations when objects are far from the camera.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="occlusion-culling">Occlusion Culling<a href="#occlusion-culling" class="hash-link" aria-label="Direct link to Occlusion Culling" title="Direct link to Occlusion Culling" translate="no">​</a></h4>
<p>Hiding objects that are not visible to the camera based on occlusion data reduces unnecessary rendering calculations.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="dynamic-batching">Dynamic Batching<a href="#dynamic-batching" class="hash-link" aria-label="Direct link to Dynamic Batching" title="Direct link to Dynamic Batching" translate="no">​</a></h4>
<p>Combining multiple small objects with the same materials into single draw calls reduces the number of rendering operations.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="shader-optimization">Shader Optimization<a href="#shader-optimization" class="hash-link" aria-label="Direct link to Shader Optimization" title="Direct link to Shader Optimization" translate="no">​</a></h4>
<p>Using efficient shaders and minimizing overdraw helps maintain high frame rates in complex scenes.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="code-examples">Code Examples<a href="#code-examples" class="hash-link" aria-label="Direct link to Code Examples" title="Direct link to Code Examples" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-c-script-for-camera-sensor-simulation">Unity C# Script for Camera Sensor Simulation<a href="#unity-c-script-for-camera-sensor-simulation" class="hash-link" aria-label="Direct link to Unity C# Script for Camera Sensor Simulation" title="Direct link to Unity C# Script for Camera Sensor Simulation" translate="no">​</a></h3>
<p>Here&#x27;s an example of how to implement camera sensor simulation in Unity:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.IO;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[RequireComponent(typeof(Camera))]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CameraSensor : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Camera Settings&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int imageWidth = 640;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int imageHeight = 480;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float fieldOfView = 60f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string outputDirectory = &quot;CameraOutput&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Sensor Simulation&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool simulateDepth = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float minDepth = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxDepth = 100f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool simulateSemanticSegmentation = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Camera cam;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private RenderTexture renderTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Texture2D outputTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam = GetComponent&lt;Camera&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SetupCamera();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CreateRenderTexture();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SetupCamera()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.fieldOfView = fieldOfView;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.enabled = false; // Disable default rendering</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void CreateRenderTexture()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        renderTexture = new RenderTexture(imageWidth, imageHeight, 24);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        renderTexture.format = RenderTextureFormat.ARGB32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        renderTexture.antiAliasing = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        renderTexture.Create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        outputTexture = new Texture2D(imageWidth, imageHeight, TextureFormat.RGB24, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void CaptureImage()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set the camera&#x27;s target texture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.targetTexture = renderTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Render the camera</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.Render();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Read the render texture into the output texture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = renderTexture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        outputTexture.ReadPixels(new Rect(0, 0, imageWidth, imageHeight), 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        outputTexture.Apply();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Reset render texture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.targetTexture = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Save the image</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SaveImage(outputTexture, &quot;rgb_image&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void CaptureDepthImage()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!simulateDepth) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create a temporary render texture for depth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture depthRT = RenderTexture.GetTemporary(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imageWidth, imageHeight, 24, RenderTextureFormat.RFloat);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Set up camera for depth rendering</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.SetTargetBuffers(depthRT.colorBuffer, depthRT.depthBuffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.RenderWithShader(Shader.Find(&quot;Hidden/DepthOnly&quot;), &quot;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Read depth data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = depthRT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Texture2D depthTexture = new Texture2D(imageWidth, imageHeight, TextureFormat.RFloat, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTexture.ReadPixels(new Rect(0, 0, imageWidth, imageHeight), 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        depthTexture.Apply();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Reset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.active = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cam.ResetReplacementShader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Save the depth image</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SaveImage(depthTexture, &quot;depth_image&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Clean up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RenderTexture.ReleaseTemporary(depthRT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DestroyImmediate(depthTexture);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void SaveImage(Texture2D texture, string prefix)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] bytes = texture.EncodeToPNG();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create directory if it doesn&#x27;t exist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        string fullDir = Path.Combine(Application.dataPath, outputDirectory);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!Directory.Exists(fullDir))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Directory.CreateDirectory(fullDir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Generate filename with timestamp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        string filename = $&quot;{prefix}_{DateTime.Now:yyyyMMdd_HHmmss}.png&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        string filepath = Path.Combine(fullDir, filename);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        File.WriteAllBytes(filepath, bytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;Image saved to: {filepath}&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void OnDestroy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (renderTexture != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            renderTexture.Release();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (outputTexture != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            DestroyImmediate(outputTexture);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-c-script-for-lidar-simulation">Unity C# Script for LIDAR Simulation<a href="#unity-c-script-for-lidar-simulation" class="hash-link" aria-label="Direct link to Unity C# Script for LIDAR Simulation" title="Direct link to Unity C# Script for LIDAR Simulation" translate="no">​</a></h3>
<p>Here&#x27;s an example of how to simulate LIDAR sensors in Unity:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections.Generic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class LIDARSensor : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;LIDAR Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numberOfRays = 360;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float minAngle = -90f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxAngle = 90f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float maxDistance = 20f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LayerMask detectionMask = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string outputTopic = &quot;/laser_scan&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Performance&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float updateRate = 10f; // Hz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool visualizeRays = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private LineRenderer lineRenderer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float updateInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float lastUpdateTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Data structure for LIDAR output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [System.Serializable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class LaserScanData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float[] ranges;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float angle_min;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float angle_max;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float angle_increment;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float time_increment;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float scan_time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float range_min;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public float range_max;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateInterval = 1f / updateRate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastUpdateTime = 0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (visualizeRays)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SetupLineRenderer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SetupLineRenderer()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lineRenderer = gameObject.AddComponent&lt;LineRenderer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lineRenderer.material = new Material(Shader.Find(&quot;Sprites/Default&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lineRenderer.widthMultiplier = 0.02f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lineRenderer.positionCount = numberOfRays + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lineRenderer.useWorldSpace = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Time.time - lastUpdateTime &gt;= updateInterval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PerformLIDARScan();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastUpdateTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LaserScanData PerformLIDARScan()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LaserScanData scanData = new LaserScanData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.ranges = new float[numberOfRays];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.angle_min = minAngle * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.angle_max = maxAngle * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.angle_increment = (maxAngle - minAngle) * Mathf.Deg2Rad / numberOfRays;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.time_increment = 0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.scan_time = updateInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.range_min = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scanData.range_max = maxDistance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float angleStep = (maxAngle - minAngle) / numberOfRays;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; numberOfRays; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float angle = minAngle + i * angleStep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float radians = angle * Mathf.Deg2Rad;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Calculate ray direction in local space</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 rayDirection = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Mathf.Cos(radians),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                0f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Mathf.Sin(radians)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Transform to world space</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 worldRayDirection = transform.TransformDirection(rayDirection);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Perform raycast</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            RaycastHit hit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Physics.Raycast(transform.position, worldRayDirection, out hit, maxDistance, detectionMask))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                scanData.ranges[i] = hit.distance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Visualize ray if enabled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (visualizeRays &amp;&amp; lineRenderer != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lineRenderer.SetPosition(i, Vector3.zero);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lineRenderer.SetPosition(i + 1, transform.InverseTransformPoint(hit.point));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                scanData.ranges[i] = float.PositiveInfinity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Visualize ray to max distance if enabled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (visualizeRays &amp;&amp; lineRenderer != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Vector3 maxPoint = transform.InverseTransformPoint(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        transform.position + worldRayDirection * maxDistance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lineRenderer.SetPosition(i, Vector3.zero);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lineRenderer.SetPosition(i + 1, maxPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return scanData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Method to get point cloud from LIDAR data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;Vector3&gt; GetPointCloud(LaserScanData scanData)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Vector3&gt; pointCloud = new List&lt;Vector3&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 sensorPosition = transform.position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; scanData.ranges.Length; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float range = scanData.ranges[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (range &gt; scanData.range_min &amp;&amp; range &lt; scanData.range_max)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float angle = scanData.angle_min + i * scanData.angle_increment;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Calculate point in 2D plane (for 2D LIDAR)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Vector3 point = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    range * Mathf.Cos(angle),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    0f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    range * Mathf.Sin(angle)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Transform to world coordinates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                point = transform.TransformPoint(point);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pointCloud.Add(point);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pointCloud;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Method to simulate 3D LIDAR by stacking 2D scans</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;Vector3&gt; Get3DPointCloud(int verticalBeams = 16, float verticalFOV = 30f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Vector3&gt; pointCloud = new List&lt;Vector3&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int v = 0; v &lt; verticalBeams; v++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float verticalAngle = -verticalFOV / 2 + (v * verticalFOV / (verticalBeams - 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Rotate the sensor temporarily for vertical angle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 originalEuler = transform.eulerAngles;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            transform.eulerAngles = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                originalEuler.x + verticalAngle,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                originalEuler.y,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                originalEuler.z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Perform scan at this vertical angle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LaserScanData scanData = PerformLIDARScan();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;Vector3&gt; scanPoints = GetPointCloud(scanData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pointCloud.AddRange(scanPoints);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Restore original rotation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            transform.eulerAngles = originalEuler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return pointCloud;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void OnValidate()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        numberOfRays = Mathf.Clamp(numberOfRays, 1, 10000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        maxDistance = Mathf.Clamp(maxDistance, 0.1f, 1000f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateRate = Mathf.Clamp(updateRate, 0.1f, 100f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-c-script-for-imu-simulation">Unity C# Script for IMU Simulation<a href="#unity-c-script-for-imu-simulation" class="hash-link" aria-label="Direct link to Unity C# Script for IMU Simulation" title="Direct link to Unity C# Script for IMU Simulation" translate="no">​</a></h3>
<p>Here&#x27;s an example of how to simulate IMU sensors in Unity:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class IMUSensor : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;IMU Configuration&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float updateRate = 100f; // Hz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool includeGyroscope = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool includeAccelerometer = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool includeMagnetometer = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Noise Parameters&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float accelerometerNoise = 0.01f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float gyroscopeNoise = 0.01f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float magnetometerNoise = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Gravity&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 gravity = new Vector3(0, -9.81f, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float updateInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float lastUpdateTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Data structure for IMU output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [System.Serializable]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class IMUData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Vector3 linear_acceleration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Vector3 angular_velocity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Vector3 magnetic_field;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Quaternion orientation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Store previous state for velocity calculation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 previousPosition;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Quaternion previousRotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float previousTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateInterval = 1f / updateRate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastUpdateTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previousPosition = transform.position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previousRotation = transform.rotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previousTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Time.time - lastUpdateTime &gt;= updateInterval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PublishIMUData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastUpdateTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public IMUData GetIMUData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IMUData imuData = new IMUData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate linear acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (includeAccelerometer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 currentPosition = transform.position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float currentTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Calculate velocity from position changes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 velocity = (currentPosition - previousPosition) / (currentTime - previousTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 previousVelocity = (previousPosition - GetPreviousPosition(2)) / (currentTime - previousTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Calculate acceleration from velocity changes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 acceleration = (velocity - previousVelocity) / (currentTime - previousTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add gravity compensation (remove gravity from linear acceleration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuData.linear_acceleration = acceleration - transform.InverseTransformDirection(gravity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuData.linear_acceleration += AddNoiseVector(accelerometerNoise);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate angular velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (includeGyroscope)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Quaternion currentRotation = transform.rotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float currentTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Calculate angular velocity from rotation changes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Quaternion deltaRotation = currentRotation * Quaternion.Inverse(previousRotation);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 angularVelocity = new Vector3();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float deltaTime = currentTime - previousTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (deltaTime &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Convert quaternion to angular velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float angle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Vector3 axis;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                deltaRotation.ToAngleAxis(out angle, out axis);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Convert from degrees to radians and normalize by time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                angularVelocity = axis * Mathf.Deg2Rad * angle / deltaTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuData.angular_velocity = transform.InverseTransformDirection(angularVelocity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuData.angular_velocity += AddNoiseVector(gyroscopeNoise);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Simulate magnetic field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (includeMagnetometer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // In a real implementation, this would be based on geographic location</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // For simulation, we&#x27;ll use a fixed magnetic field vector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuData.magnetic_field = transform.InverseTransformDirection(new Vector3(22.9f, 0f, 44.4f)); // Approximate magnetic field in microteslas</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add noise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            imuData.magnetic_field += AddNoiseVector(magnetometerNoise);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Calculate orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imuData.orientation = transform.rotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Update previous state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previousPosition = transform.position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previousRotation = transform.rotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previousTime = Time.time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return imuData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 GetPreviousPosition(int framesAgo)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, you&#x27;d store multiple previous positions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // For simplicity, we&#x27;ll just return the last known position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return previousPosition;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector3 AddNoiseVector(float noiseLevel)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Random.Range(-noiseLevel, noiseLevel),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Random.Range(-noiseLevel, noiseLevel),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Random.Range(-noiseLevel, noiseLevel)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void PublishIMUData()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IMUData data = GetIMUData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // In a real implementation, this would publish to ROS or another messaging system</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Debug.Log($&quot;IMU Data - Accel: {data.linear_acceleration}, Gyro: {data.angular_velocity}&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Method to get acceleration in world frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 GetWorldAcceleration()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IMUData data = GetIMUData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return transform.TransformDirection(data.linear_acceleration);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Method to get angular velocity in world frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Vector3 GetWorldAngularVelocity()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IMUData data = GetIMUData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return transform.TransformDirection(data.angular_velocity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="unity-c-script-for-physics-based-environment-generation">Unity C# Script for Physics-Based Environment Generation<a href="#unity-c-script-for-physics-based-environment-generation" class="hash-link" aria-label="Direct link to Unity C# Script for Physics-Based Environment Generation" title="Direct link to Unity C# Script for Physics-Based Environment Generation" translate="no">​</a></h3>
<p>Here&#x27;s an example of how to procedurally generate physics-based environments in Unity:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System.Collections.Generic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using UnityEngine;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class PhysicsEnvironmentGenerator : MonoBehaviour</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Terrain Generation&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int terrainWidth = 200;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int terrainLength = 200;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float terrainHeight = 20f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int resolution = 256;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Object Placement&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public GameObject[] obstaclePrefabs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int minObstacles = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int maxObstacles = 50;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float placementAreaPadding = 5f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Material Properties&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public PhysicMaterial defaultMaterial;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float dynamicFriction = 0.6f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float staticFriction = 0.6f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float bounciness = 0.1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [Header(&quot;Environment Features&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool generateRandomTerrain = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool addStaticObstacles = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool addDynamicObstacles = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public bool addRamps = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int numRamps = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;GameObject&gt; spawnedObjects = new List&lt;GameObject&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private float[,] heightMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void Start()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GenerateEnvironment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void GenerateEnvironment()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClearEnvironment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (generateRandomTerrain)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GenerateTerrain();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (addStaticObstacles)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PlaceStaticObstacles();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (addDynamicObstacles)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PlaceDynamicObstacles();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (addRamps)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PlaceRamps();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void ClearEnvironment()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Destroy previously spawned objects</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (GameObject obj in spawnedObjects)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (obj != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                DestroyImmediate(obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawnedObjects.Clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void GenerateTerrain()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create terrain programmatically</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GameObject terrainObj = new GameObject(&quot;GeneratedTerrain&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Terrain terrain = terrainObj.AddComponent&lt;Terrain&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TerrainCollider terrainCollider = terrainObj.AddComponent&lt;TerrainCollider&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Create terrain data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TerrainData terrainData = new TerrainData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrainData.heightmapResolution = resolution;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrainData.size = new Vector3(terrainWidth, terrainHeight, terrainLength);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Generate heightmap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        heightMap = GenerateHeightMap(resolution, resolution);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrainData.SetHeights(0, 0, heightMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Assign the terrain data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrain.terrainData = terrainData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrainCollider.terrainData = terrainData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawnedObjects.Add(terrainObj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float[,] GenerateHeightMap(int width, int height)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float[,] heights = new float[width, height];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int x = 0; x &lt; width; x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int y = 0; y &lt; height; y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Generate Perlin noise-based terrain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float xCoord = (float)x / width * 10f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float yCoord = (float)y / height * 10f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Multiple octaves for more natural terrain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float elevation = 0f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float amplitude = 1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float frequency = 1f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float persistence = 0.5f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int octave = 0; octave &lt; 4; octave++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    elevation += Mathf.PerlinNoise(xCoord * frequency, yCoord * frequency) * amplitude;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    amplitude *= persistence;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    frequency *= 2f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Normalize to 0-1 range and apply to height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                heights[x, y] = elevation / 4f; // Divide by number of octaves for normalization</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return heights;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PlaceStaticObstacles()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int numObstacles = Random.Range(minObstacles, maxObstacles + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; numObstacles; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (obstaclePrefabs.Length == 0) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Select random obstacle prefab</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GameObject obstaclePrefab = obstaclePrefabs[Random.Range(0, obstaclePrefabs.Length)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Generate random position within bounds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 position = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(placementAreaPadding, terrainWidth - placementAreaPadding),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                10f, // Start above ground to let it fall</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(placementAreaPadding, terrainLength - placementAreaPadding)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Create obstacle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GameObject obstacle = Instantiate(obstaclePrefab, position, Quaternion.identity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add rigidbody if it doesn&#x27;t have one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (obstacle.GetComponent&lt;Rigidbody&gt;() == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Rigidbody rb = obstacle.AddComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rb.isKinematic = true; // Static obstacles</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Set material properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SetPhysicsMaterial(obstacle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            spawnedObjects.Add(obstacle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PlaceDynamicObstacles()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int numObstacles = Random.Range(minObstacles / 2, maxObstacles / 2 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; numObstacles; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (obstaclePrefabs.Length == 0) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Select random obstacle prefab</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GameObject obstaclePrefab = obstaclePrefabs[Random.Range(0, obstaclePrefabs.Length)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Generate random position within bounds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 position = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(placementAreaPadding, terrainWidth - placementAreaPadding),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                10f, // Start above ground</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(placementAreaPadding, terrainLength - placementAreaPadding)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Create obstacle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GameObject obstacle = Instantiate(obstaclePrefab, position, Quaternion.identity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add rigidbody for physics simulation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Rigidbody rb = obstacle.GetComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (rb == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rb = obstacle.AddComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Set as dynamic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rb.isKinematic = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rb.useGravity = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add random initial velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rb.velocity = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(-1f, 1f),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                0f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(-1f, 1f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ) * 2f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Set material properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SetPhysicsMaterial(obstacle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            spawnedObjects.Add(obstacle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void PlaceRamps()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; numRamps; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Create a ramp object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GameObject ramp = GameObject.CreatePrimitive(PrimitiveType.Capsule);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ramp.name = &quot;Ramp_&quot; + i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Position the ramp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Vector3 position = new Vector3(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(placementAreaPadding + 10, terrainWidth - placementAreaPadding - 10),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                5f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Random.Range(placementAreaPadding + 10, terrainLength - placementAreaPadding - 10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ramp.transform.position = position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Rotate to create an incline</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            float angle = Random.Range(15f, 45f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ramp.transform.rotation = Quaternion.Euler(angle, Random.Range(0f, 360f), 0f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Scale to make it ramp-like</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ramp.transform.localScale = new Vector3(0.5f, 5f, 3f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Add rigidbody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Rigidbody rb = ramp.AddComponent&lt;Rigidbody&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rb.isKinematic = true; // Static ramp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Set material properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SetPhysicsMaterial(ramp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Remove the collider and add a box collider instead for better physics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            DestroyImmediate(ramp.GetComponent&lt;CapsuleCollider&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BoxCollider boxCollider = ramp.AddComponent&lt;BoxCollider&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boxCollider.size = new Vector3(1f, 10f, 6f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            spawnedObjects.Add(ramp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void SetPhysicsMaterial(GameObject obj)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PhysicMaterial material = defaultMaterial;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (material == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            material = new PhysicMaterial(&quot;GeneratedMaterial&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            material.dynamicFriction = dynamicFriction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            material.staticFriction = staticFriction;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            material.bounciness = bounciness;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Apply material to all colliders in the object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collider[] colliders = obj.GetComponentsInChildren&lt;Collider&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foreach (Collider collider in colliders)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            collider.material = material;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Method to modify terrain height at a specific point (for dynamic terrain modification)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void ModifyTerrainHeight(Vector3 worldPosition, float heightDelta, float radius)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (heightMap == null) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Terrain terrain = GetComponent&lt;Terrain&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (terrain == null) return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TerrainData terrainData = terrain.terrainData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Vector3 terrainPos = terrain.GetPosition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Convert world position to terrain coordinates</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float xPercent = (worldPosition.x - terrainPos.x) / terrainData.size.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float zPercent = (worldPosition.z - terrainPos.z) / terrainData.size.z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int centerX = (int)(xPercent * terrainData.heightmapResolution);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int centerZ = (int)(zPercent * terrainData.heightmapResolution);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int radiusInSamples = (int)(radius * terrainData.heightmapResolution / terrainData.size.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Modify height within radius</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int x = Mathf.Max(0, centerX - radiusInSamples); x &lt; Mathf.Min(terrainData.heightmapResolution, centerX + radiusInSamples); x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int z = Mathf.Max(0, centerZ - radiusInSamples); z &lt; Mathf.Min(terrainData.heightmapResolution, centerZ + radiusInSamples); z++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float distance = Mathf.Sqrt(Mathf.Pow(x - centerX, 2) + Mathf.Pow(z - centerZ, 2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (distance &lt;= radiusInSamples)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float falloff = 1f - (distance / radiusInSamples);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    heightMap[x, z] += heightDelta * falloff;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    heightMap[x, z] = Mathf.Clamp01(heightMap[x, z]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Apply the modified heightmap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrainData.SetHeights(0, 0, heightMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="exercises">Exercises<a href="#exercises" class="hash-link" aria-label="Direct link to Exercises" title="Direct link to Exercises" translate="no">​</a></h2>
<ol>
<li class="">Create a Unity scene with realistic lighting and materials using PBR</li>
<li class="">Implement a camera sensor simulation that outputs RGB and depth images</li>
<li class="">Develop a LIDAR simulation system that outputs realistic point cloud data</li>
<li class="">Create an IMU simulation that provides accurate acceleration and rotation data</li>
<li class="">Build a procedural environment generator with physics-based objects</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">Unity Rendering Documentation: <a href="https://docs.unity3d.com/Manual/rendering-index.html" target="_blank" rel="noopener noreferrer" class="">https://docs.unity3d.com/Manual/rendering-index.html</a></li>
<li class="">Unity HDRP Documentation: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@latest" target="_blank" rel="noopener noreferrer" class="">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@latest</a></li>
<li class="">Unity Robotics Package: <a href="https://github.com/Unity-Technologies/Unity-Robotics-Hub" target="_blank" rel="noopener noreferrer" class="">https://github.com/Unity-Technologies/Unity-Robotics-Hub</a></li>
<li class="">Unity Perception Package: <a href="https://github.com/Unity-Technologies/Unity-Perception" target="_blank" rel="noopener noreferrer" class="">https://github.com/Unity-Technologies/Unity-Perception</a></li>
<li class="">Physically-Based Rendering in Unity: <a href="https://docs.unity3d.com/Manual/MaterialsMenu.html" target="_blank" rel="noopener noreferrer" class="">https://docs.unity3d.com/Manual/MaterialsMenu.html</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/muhammadwaheedairi/hackathon_textbook_ai_robotics/edit/main/my-website/docs/module-2-digital-twin/week-5-high-fidelity-rendering-in-unity.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/hackathon_textbook_ai_robotics/docs/module-2-digital-twin/week-4-physics-simulation-in-gazebo"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Week 4: Physics Simulation in Gazebo</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/hackathon_textbook_ai_robotics/docs/module-3-ai-robot-brain/week-6-nvidia-isaac-sim"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Week 6 - NVIDIA Isaac Sim</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#learning-objectives" class="table-of-contents__link toc-highlight">Learning Objectives</a></li><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#theory" class="table-of-contents__link toc-highlight">Theory</a><ul><li><a href="#unity-rendering-pipelines" class="table-of-contents__link toc-highlight">Unity Rendering Pipelines</a></li><li><a href="#physically-based-rendering-pbr" class="table-of-contents__link toc-highlight">Physically-Based Rendering (PBR)</a></li><li><a href="#lighting-systems-in-unity" class="table-of-contents__link toc-highlight">Lighting Systems in Unity</a></li><li><a href="#unity-sensor-simulation" class="table-of-contents__link toc-highlight">Unity Sensor Simulation</a></li><li><a href="#unity-robotics-integration" class="table-of-contents__link toc-highlight">Unity Robotics Integration</a></li><li><a href="#performance-optimization-for-real-time-rendering" class="table-of-contents__link toc-highlight">Performance Optimization for Real-Time Rendering</a></li></ul></li><li><a href="#code-examples" class="table-of-contents__link toc-highlight">Code Examples</a><ul><li><a href="#unity-c-script-for-camera-sensor-simulation" class="table-of-contents__link toc-highlight">Unity C# Script for Camera Sensor Simulation</a></li><li><a href="#unity-c-script-for-lidar-simulation" class="table-of-contents__link toc-highlight">Unity C# Script for LIDAR Simulation</a></li><li><a href="#unity-c-script-for-imu-simulation" class="table-of-contents__link toc-highlight">Unity C# Script for IMU Simulation</a></li><li><a href="#unity-c-script-for-physics-based-environment-generation" class="table-of-contents__link toc-highlight">Unity C# Script for Physics-Based Environment Generation</a></li></ul></li><li><a href="#exercises" class="table-of-contents__link toc-highlight">Exercises</a></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div><button class="floating-chatbot-button" aria-label="Open chatbot" aria-expanded="false">💬</button><div class="floating-chatbot-container" role="dialog" aria-modal="true" aria-label="RAG Chatbot Interface"><button class="floating-chatbot-close" aria-label="Close chatbot">×</button><div class="container_W2Ls" role="region" aria-label="RAG Question and Answer Interface"><form class="form_mldX" role="form" aria-label="Question submission form"><div class="inputContainer_EFpc"><label for="rag-question-input" class="inputLabel_SakW">Ask a question about the textbook content:</label><textarea id="rag-question-input" placeholder="Ask a question about the textbook content..." class="textarea_w2uq" rows="3" aria-invalid="false" aria-required="true"></textarea><button type="submit" class="submitButton_vR2i" disabled="" aria-label="Submit question">Ask</button></div></form></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Textbook</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/hackathon_textbook_ai_robotics/docs/intro">Introduction</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://docs.ros.org/en/humble/" target="_blank" rel="noopener noreferrer" class="footer__link-item">ROS 2 Documentation<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://developer.nvidia.com/isaac" target="_blank" rel="noopener noreferrer" class="footer__link-item">NVIDIA Isaac<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://gazebosim.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gazebo Simulation<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/hackathon_textbook_ai_robotics/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/muhammadwaheedairi/hackathon_textbook_ai_robotics" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 AI-Native Textbook — Physical AI & Humanoid Robotics. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>